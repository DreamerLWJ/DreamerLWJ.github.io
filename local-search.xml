<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前后端如何高效协同</title>
    <link href="/2022/0948c22078.html"/>
    <url>/2022/0948c22078.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Leader 路过组的工位，发现前后端打起架来了，原来是…</p><h2 id="好工具"><a href="#好工具" class="headerlink" title="好工具"></a>好工具</h2><h2 id="好流程"><a href="#好流程" class="headerlink" title="好流程"></a>好流程</h2>]]></content>
    
    
    <categories>
      
      <category>项目管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>作为一名新人程序员你需要学会生存！</title>
    <link href="/2022/0936ce6981.html"/>
    <url>/2022/0936ce6981.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>同学，你写的 bug 长得真像程序～</p></blockquote><h2 id="温馨提醒"><a href="#温馨提醒" class="headerlink" title="温馨提醒"></a>温馨提醒</h2><p>作为一个编程的新手，我们会遇到各种各样的问题，我们会忍不住求助他人，尤其是师兄师姐。师兄师姐有时候会很头疼，主要是这几点，</p><ol><li>遇到错误就立刻问师兄师姐，不知道如何初步排查错误</li><li>提问方式很有问题，给对方的认知成本很高</li><li>有的问题可能多问问浏览器就能轻松得出答案</li></ol><h2 id="新人如何初步排查程序的错误？"><a href="#新人如何初步排查程序的错误？" class="headerlink" title="新人如何初步排查程序的错误？"></a>新人如何初步排查程序的错误？</h2><p>“师兄，师兄“，我的程序是这样的，为什么我的输出不对？<strong>然后微信上截图一个程序，或者更加糟糕的是直接用手机拍照电脑屏幕，</strong></p><p>我们先看一个实例，这里我以一个冒泡排序为基准为朋友们讲解通用的程序错误排查思路，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, t, a[<span class="hljs-number">11</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入10个数：\n&quot;</span>);<br><br>  <span class="hljs-comment">// 输入</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>  <span class="hljs-comment">// 冒泡排序</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">11</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) &#123;<br>                a[j] = a[j + <span class="hljs-number">1</span>];<br>                a[j + <span class="hljs-number">1</span>] = a[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序后的顺序是：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <br>  <span class="hljs-comment">// 防止控制台类型程序过早退出</span><br>  getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于大多数程序而言，我们要做的无非就是接收外部输入，然后给出输出结果，于是我将程序的大多数问题归结为以下两点，</p><ul><li>从输入开始就是错的</li><li>程序的逻辑问题</li></ul><p>而我也将会从这两点开始介绍如何排查问题的思路。</p><h2 id="确认你的输入是否正确！"><a href="#确认你的输入是否正确！" class="headerlink" title="确认你的输入是否正确！"></a>确认你的输入是否正确！</h2><p>所以我们首先要确认输入是否真的正常工作，那我们有几种办法，我这里介绍 print 和 debug 的方法。</p><h2 id="1-just-print-it"><a href="#1-just-print-it" class="headerlink" title="1. just print it"></a>1. just print it</h2><p>在上面的程序中，我们希望将 10 个数字输入到我们的数组 a 中，那么我们可以在 scanf 结束的时候打印我们输入的各个值，以确认输入是否按照我们的意愿正常工作。比如对上面的程序稍作修改，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, t, a[<span class="hljs-number">11</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入10个数：\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>  <span class="hljs-comment">// 在输入后通过 print 的方式检查你的输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的值为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br><br>...... <span class="hljs-comment">// 省略其他代码，在调试输入的时候，这部分代码也可以先注释掉</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 scanf 后我加了一段 printf 语句，来检查我的 scanf 输入的值。</p><p>我们可能有各种各样的输入，以下是工作正常的输入，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>我的控制台如图所示，正常地输出了每一个值，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925010929643.png" alt="控制台输出" style="zoom:50%;" /><p>但是当我的输入变成了这样的时候，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>输出如下所示，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925011037052.png" alt="image-20220925011037052" style="zoom:50%;" /><p>你看，不同的输入可能会产生不同的结果，所以检查你的输入是非常重要的！而我见过的大多数问题就是，没有对输入做检查，只是把程序跑了一遍，发现结果不对就来问。</p><p>这是我给你的第一个技巧。我们可以在可能出现错误的各个步骤前后添加一个 print 语句，这样也是一种非常实用的方案。</p><p>但是如果一个程序的步骤特别多，我们没有那么多时间精力去修改代码，或者说文件对你来说是“只读”的，你无法修改。这时候就要用到我下文介绍的 <strong>Debug</strong> 功能。</p><h2 id="2-Debug"><a href="#2-Debug" class="headerlink" title="2. Debug"></a>2. Debug</h2><blockquote><p>对于一些学了一年以上编程连 debug 都不会的童鞋，我想说，先坐个牢。新人的话可以好好看看～</p></blockquote><p>你安装的 IDE 有不少按钮，不知道你是否注意过一个“debug”的按钮，我首先来介绍一下如何使用 Dev C++ 这款“神器”来调试我们的程序吧。</p><p>作为一个程序猿，我们是要靠工具吃饭的，手上的家伙儿一定要整明白。比如你在 Dev C++，你写了一个“完美”的程序，如图所示，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925020501639.png" alt="image-20220925020501639" style="zoom:67%;" /><p>你的程序就安静地躺在这里～，注意我用红色框框圈出的 4 个按钮，这 4 个按钮可能会陪伴你走过这一学期，从左到右的功能分别如下所示：</p><ul><li>Complie：编译，你的源代码要运行前必须编译成机器码！</li><li>Run：运行，这不用说吧</li><li>Complie &amp; Run：编译并运行，如果你觉得上面的两个按钮太麻烦，可以试试这个</li><li>Rebuild All：重新编译</li></ul><p>除了把程序 Run 起来之外，还有一个重要的功能往往被大家忽略，那就是 <strong>Debug</strong> 功能，在这呢，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925021305224.png" alt="image-20220925021305224" style="zoom: 67%;" /><p>这个工具具体怎么用呢？听我后文分解。</p><h3 id="Debug-是世界上最好的-Debug-工具"><a href="#Debug-是世界上最好的-Debug-工具" class="headerlink" title="Debug 是世界上最好的 Debug 工具"></a><code>Debug</code> 是世界上最好的 Debug 工具</h3><p>当你点击了上面的 Debug 按钮，即可开始代码调试，然后你可能会弹出一个框，记得选 No，否则你的 Dev C++ 会退出，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925023131580.png" alt="image-20220925023131580" style="zoom:50%;" /><p>然后你的界面大概会像我这样，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925021738714.png" alt="image-20220925021738714" style="zoom:50%;" /><p>除了弹出一个该有的控制台之外，还会在下面出现一个菜单栏，这个就是 Debug 菜单，当你输入之后，貌似程序直接退出了。好像没有什么我想要的效果？</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925022214308.png" alt="image-20220925022214308" style="zoom:50%;" /><p>那是因为我们没有添加一个叫做<strong>“断点”</strong>的东西。</p><h3 id="断点（break-point）"><a href="#断点（break-point）" class="headerlink" title="断点（break point）"></a>断点（break point）</h3><p><strong>所谓断点就是我希望停下来排查错误的程序语句</strong>，当你预先设置了断点后，<strong>调试功能会让程序运行到断点时停下来</strong>，就像世界停止了一样（Stop the world）。</p><p>而大多数 IDE 添加断点的方式就是在对应的代码行的左边点击一下，比如我在上面的程序的第 12 行设置一个断点，点击一下数字 12，Dev C++ 显示如下，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925022843486.png" alt="image-20220925022843486" style="zoom: 67%;" /><p>对应行的代码将会变成红色，这就代表我们设置了一个断点。</p><p>要想使用 Dev C++ 的调试功能，我们还需要稍微配置一下，（因为它有点毛病</p><p>到 Tools - Compiler Options，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925024133167.png" alt="image-20220925024133167" style="zoom:75%;" /><p>然后把 Settings - Linker 的 Generate debugging information 给它改成 Yes，然后别忘记点击 OK，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925024150202.png" alt="image-20220925024150202" style="zoom:50%;" /><p>现在让我们<strong>重新编译</strong>后，再次点击“Debug”（或键盘 F5）。</p><p>在控制台输入后回车，根据控制台的输出信息，你会发现代码停在了断点处，并且原先红色的行变成了蓝色，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925025211674.png" alt="image-20220925025211674" style="zoom: 50%;" /><p>而接下来如何控制和操作代码的运行，就看下方的 Debug 控制栏了，为了更好地介绍每个功能，我先放一张图，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925030103656.png" alt="image-20220925030103656" style="zoom:50%;" /><h3 id="Watch-功能"><a href="#Watch-功能" class="headerlink" title="Watch 功能"></a>Watch 功能</h3><p>如果我想在调试的过程中监视某个变量的值时，我应该怎么做？没错，那就是 Watch 功能啦，比如我现在要看数组 a 的值，我可以点击 Add Watch 然后输入 a，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925030431278.png" alt="image-20220925030431278" style="zoom:50%;" /><p>点击 OK 后，你会发现左边的 Debug 栏中出现了数组 a 及其值，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925030530034.png" alt="image-20220925030530034" style="zoom:50%;" /><p>可以看到这时候 a 的数组成功接收了我们的输入，如果你要同时 Watch 多个变量添加它们即可，你可以试试看，我这里又添加了一个 i 变量，可以看到我这边初始化 i 的值为 11。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925031004053.png" alt="image-20220925031004053" style="zoom:50%;" /><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>我们想要让程序执行当前断点所在的语句，我们可以通过 Next Line 实现，比如我点击了一次 Next Line，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925031229032.png" alt="image-20220925031229032" style="zoom:50%;" /><p>可以看到下一行代码变成了蓝色，i 被赋值为 1。在 Dev C++ 中，蓝色行代表当前调试所在的语句（即将执行的语句），而红色行为断点所在的语句。如果你想要一步步地观察程序的执行，你就可以通过 Next line 实现。</p><h3 id="释放当前断点（或到下一个断点）"><a href="#释放当前断点（或到下一个断点）" class="headerlink" title="释放当前断点（或到下一个断点）"></a>释放当前断点（或到下一个断点）</h3><p>如果你希望释放程序执行，你可以通过 Continue 按钮实现，点击它后程序将会直接执行到结束。</p><p>如果你在释放的位置后又添加了断点，那么程序将会执行直至遇到下一个断点，比如我在第 22 行又设置了断点，然后在第 13 行释放了断点，你将会看到下面的现象，</p><blockquote><p>断点是可以在调试过程中动态增加和删除的</p></blockquote><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925031849931.png" alt="image-20220925031849931" style="zoom: 67%;" /><p>没错，程序在第 22 行也就是下一个断点所在的位置停下了。</p><h3 id="进入（跳入）函数和跳过（跳出）函数"><a href="#进入（跳入）函数和跳过（跳出）函数" class="headerlink" title="进入（跳入）函数和跳过（跳出）函数"></a>进入（跳入）函数和跳过（跳出）函数</h3><p>其实当你知道上面的功能之后，你已经能应付现阶段大多数调试场景了，但是对于<strong>函数的调用</strong>，我们还需要一组更加完备的调试功能。</p><p>比如我喜欢皮，我把排序的过程，放到了一个 sort 函数里，然后在 main 函数中调用了它，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, t, a[<span class="hljs-number">11</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入10个数：\n&quot;</span>);<br><br>    <span class="hljs-comment">// 输入</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &amp;lt; <span class="hljs-number">11</span>; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;amp;a[i]);<br><br>    <span class="hljs-comment">// 冒泡排序</span><br>    sort(a, i, j);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序后的顺序是：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &amp;lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &amp;lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &amp;lt; <span class="hljs-number">11</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &amp;gt; a[j + <span class="hljs-number">1</span>]) &#123;<br>                a[j] = a[j + <span class="hljs-number">1</span>];<br>                a[j + <span class="hljs-number">1</span>] = a[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加入我们在调用 sort 的这一行打了断点，那接下来有几种选择，如果我选择了 Next Line，那么 sort 函数将会直接执行完毕。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925032939935.png" alt="image-20220925032939935" style="zoom:67%;" /><p>如果我想要进入 sort 函数，那就要用 Into function 功能了，也就是跳入这个函数，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925033106363.png" alt="image-20220925033106363" style="zoom:67%;" /><p>这时候你可以看到，调试行跳转到了 sort 函数内部，然后你可以继续通过 Next line 来逐行调试。</p><p>如果我希望继续执行直至当前函数结束，那么可以使用 Skip function 功能来跳出这个函数，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925033630405.png" alt="image-20220925033630405" style="zoom:67%;" /><p>这时候可以看到函数被跳出了。</p><p>可以看到如果利用好跳入和跳出功能，我们可以轻松地在函数之间调试。</p><h3 id="Evaluate"><a href="#Evaluate" class="headerlink" title="Evaluate"></a>Evaluate</h3><p>如果我想不修改代码的情况下，通过调试动态地查看某些表达式的结果，要怎么做？那就是强大的 Evaluate 功能了。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925034056487.png" alt="image-20220925034056487" style="zoom:67%;" /><p>比如我可以在 Stop the World 的时候，算变量 i 与 j 的差。在 Evaluate 输入框中键入我们想要的表达式，然后回车，它将会为你展现结果。这个表达式可以是任何代码语句，包括函数调用。</p><h3 id="辛苦了，总结一下-Debug-功能吧～"><a href="#辛苦了，总结一下-Debug-功能吧～" class="headerlink" title="辛苦了，总结一下 Debug 功能吧～"></a>辛苦了，总结一下 Debug 功能吧～</h3><ul><li>一断点<ul><li>break point</li></ul></li><li>一监视<ul><li>watch</li></ul></li><li>四控制<ul><li>下一步（next）</li><li>跳入（into）</li><li>跳出（skip）</li><li>释放（到下一个断点）（continue）</li></ul></li><li>一评估<ul><li>evaluate</li></ul></li></ul><h2 id="排错思维"><a href="#排错思维" class="headerlink" title="排错思维"></a>排错思维</h2><p>面对一个你写的 Bug，啊不，是你写的代码。其中的逻辑关系可能错综复杂，任何一行的执行结果都可能收到前面语句的影响，要想很好地找到 Bug ，这个讨厌的小虫子的关键位置，我们需要掌握好几点排错的思维。</p><blockquote><p>当然如果你是一个带善人喜欢帮人 debug，那么这种学习精神也是值得 salute 的～</p></blockquote><h3 id="控制变量"><a href="#控制变量" class="headerlink" title="控制变量"></a>控制变量</h3><p>当你有一个函数的计算结果依赖多个输入时，而不巧的是，这个函数有 Bug，那么你不妨试试控制变量的方式来判断可能造成问题的输入。</p><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>你写的代码可能由多条语句构成的，你需要找到 bug 所在的语句，你可以试试二分的思想，你可以从代码最后一个语句开始往前打断点，直到遇到第一个正确执行的语句时，问题往往就发生在它的后一个语句。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">语句<span class="hljs-number">1</span><br>语句<span class="hljs-number">2</span>（打了断点没问题，啊！<span class="hljs-keyword">Bug </span>在这后面）<br>语句<span class="hljs-number">3</span>（打了断点有问题）<br>语句<span class="hljs-number">4</span>（打了断点有问题）<br>语句<span class="hljs-number">5</span>（打了断点有问题）<br></code></pre></td></tr></table></figure><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>你也可以试着从第一条语句开始，用 Next line 的功能去逐行找 Bug 的位置，</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit">语句<span class="hljs-number">1</span>（没问题，<span class="hljs-keyword">next</span>）<br>语句<span class="hljs-number">2</span>（没问题，<span class="hljs-keyword">next</span>）<br>语句<span class="hljs-number">3</span>（有问题，Bug 在这！）<br>语句<span class="hljs-number">4</span><br>语句<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="推理和验证"><a href="#推理和验证" class="headerlink" title="推理和验证"></a>推理和验证</h3><p>是的，当你面对的是一个非常庞大的💩山时，我上面介绍的问题所需要的时间成本会非常高。</p><p>但是我们可以通过输出的现象对问题本身的可能性做一些推理，从而判断可能产生问题的位置，然后通过断点或者 print 的方式来验证这些位置或者范围是否有位置。</p><h2 id="提问的艺术"><a href="#提问的艺术" class="headerlink" title="提问的艺术"></a>提问的艺术</h2><ul><li>用手机拍照电脑代码，让人欣赏显示屏的丝滑</li><li>截图不完整，另一部分要我猜？</li><li>扔过来一坨代码，“师兄，为什么我的输出是错的？”</li><li>问的问题不是问题，你要我怎么回答</li><li>同学你的缩进让我的眼睛很心疼，你能不能格式化一下？</li></ul><p>…</p><p>OK，经历了多届新生的打磨，我已经逝去了原来的 patient，</p><blockquote><p>尽管我还是有 patient 来写这个文章</p></blockquote><p>我想说的，当你提问的时候，应该想想怎么样让对方花最少的时间理解你的问题，降低彼此的沟通成本。你的每一个漫不经心的微信消息都可能浪费他人的时间。</p><p>那么对我来说，如果你打算私信来问我问题，那么你需要做好以下准备，</p><ul><li>被我批评的准备</li><li>告诉我你做了一些尝试，尝试的结果是？比如搜索引擎，debug 缩小问题范围</li><li>清晰的<strong>代码格式</strong>和清晰的<strong>输入输出</strong></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="VSCode-如何-Debug"><a href="#VSCode-如何-Debug" class="headerlink" title="VSCode 如何 Debug"></a>VSCode 如何 Debug</h3><p>记得在你的工程中的 tasks.json 中添加这个，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;presentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;panel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;new&quot;</span> <span class="hljs-comment">// 默认为“shared“表示共享控制台，new 表示每个进程都创建新的控制台</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>否则你将无法输入 scanf 的内容，下面是修改之后的 json 示例，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-comment">// 添加在这里</span><br>            <span class="hljs-attr">&quot;presentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>                <span class="hljs-attr">&quot;panel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;new&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 记得不要漏 &quot;,&quot;</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;调试器生成的任务。&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p> 如果你感兴趣的话，可以了解一下 json 数据格式</p></blockquote><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925041115178.png" alt="image-20220925041115178" style="zoom:67%;" /><h3 id="Clion-如何-Debug"><a href="#Clion-如何-Debug" class="headerlink" title="Clion 如何 Debug"></a>Clion 如何 Debug</h3><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220925040356578.png" alt="image-20220925040356578" style="zoom: 67%;" /><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>你看不同的 IDE 其实调试的使用方法是一样的，调试只需要掌握常见调试功能和排错的思维，找 bug 那不分分钟的事情？如果一个程序猿连 debug 都不会，那一定不是合格的程序猿，那他在我眼里就一定要坐牢！</p>]]></content>
    
    
    <categories>
      
      <category>给新人看的</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Docker 轻松构建集群环境</title>
    <link href="/2022/09c226167.html"/>
    <url>/2022/09c226167.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仍会持续更新</p></blockquote><p>As a Javaer，在 《Tool 杂谈——高效配置 Centos 集群环境》一文中我们借助了 VMware 为大家介绍如何高效配置集群环境，这些经验也希望读者能够转换为线上服务集群的搭建与配置。为了更加深入地让读者知道如何利用搭建好的集群环境来快速搭建一个中间件的集群环境，我们在</p><h2 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h2><p>你有一台电脑，并且安装好了 Docker。</p><h2 id="2-必备知识"><a href="#2-必备知识" class="headerlink" title="2. 必备知识"></a>2. 必备知识</h2><h3 id="2-1-Docker-网络模式"><a href="#2-1-Docker-网络模式" class="headerlink" title="2.1 Docker 网络模式"></a>2.1 Docker 网络模式</h3><p>Docker 主要有几种网络模式，我们通过一个命令就可以查看当前 Docker 环境下的网络，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network ls<br></code></pre></td></tr></table></figure><p>以下为我的控制台输出，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">NETWORK ID     NAME      DRIVER    SCOPE<br>2ce03ba56617   bridge    bridge    local<br>c40aa25c852b   host      host      local<br>1259d5627c17   none      null      local<br></code></pre></td></tr></table></figure><p>可以看到 DRIVER 字段，为我们展示了默认的三种网络模式，桥接网络（Bridge）</p><h4 id="桥接网络"><a href="#桥接网络" class="headerlink" title="桥接网络"></a>桥接网络</h4><p>桥接网络是网络段之间转发流量的基础设施，这个基础设施可以是硬件也可以是像 Docker 这样的软件设施。容器运行在自己单独的 network namespace 中，有单独的协议栈，宿主机与容器的网络交互通过网桥网关实现，容器与外部网络的交互则要在其基础上加上 NAT 转换。</p><p>我们我们查看一下 bridge 网络的详细信息，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network inspect bridge<br></code></pre></td></tr></table></figure><p>我的输出如下所示，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2ce03ba5661718e1f00a6dd694591ff00df2e24440864eb268fe9e77215101ef&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Created&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-09-03T15:10:27.478225Z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;EnableIPv6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;IPAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;Subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.17.0.0/16&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// bridge</span><br>                    <span class="hljs-attr">&quot;Gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.17.0.1&quot;</span> <br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Internal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Attachable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Ingress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConfigFrom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Network&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConfigOnly&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Containers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;com.docker.network.bridge.default_bridge&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;true&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// docker 默认的 bridge 网络</span><br>            <span class="hljs-attr">&quot;com.docker.network.bridge.enable_icc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;true&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;true&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;com.docker.network.bridge.name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docker0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;com.docker.network.driver.mtu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1500&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h3 id="2-2-NAT-网络转换"><a href="#2-2-NAT-网络转换" class="headerlink" title="2.2 NAT 网络转换"></a>2.2 NAT 网络转换</h3><h2 id="3-定个小目标——赚它一个亿"><a href="#3-定个小目标——赚它一个亿" class="headerlink" title="3. 定个小目标——赚它一个亿"></a>3. 定个小目标——赚它一个亿</h2><p>这次我们的构建目标如下，帮助大家在生产环境中轻松构建 Centos 集群，</p><h3 id="3-1-搭建-Centos-集群"><a href="#3-1-搭建-Centos-集群" class="headerlink" title="3.1 搭建 Centos 集群"></a>3.1 搭建 Centos 集群</h3><h3 id="3-2-在集群基础上构建-Kafka-集群"><a href="#3-2-在集群基础上构建-Kafka-集群" class="headerlink" title="3.2 在集群基础上构建 Kafka 集群"></a>3.2 在集群基础上构建 Kafka 集群</h3><h3 id="3-3-Docker-Compose-自动化构建过程"><a href="#3-3-Docker-Compose-自动化构建过程" class="headerlink" title="3.3 Docker Compose 自动化构建过程"></a>3.3 Docker Compose 自动化构建过程</h3><h2 id="4-制作基础镜像"><a href="#4-制作基础镜像" class="headerlink" title="4. 制作基础镜像"></a>4. 制作基础镜像</h2><p>为了复制多个实例的集群，我们首先制作一个包含 JDK、Kafka 环境的 Centos，制作的方法有几种，我们主要介绍两种，自己动手丰衣足素和 Dockerfile 方式构建镜像。</p><h3 id="4-1-自己动手制作镜像"><a href="#4-1-自己动手制作镜像" class="headerlink" title="4.1 自己动手制作镜像"></a>4.1 自己动手制作镜像</h3><p>手动制作很简单，我们先把 Centos 容器跑起来，然后进入容器中配置我们的环境，配置完成后就可以将容器重新生成为镜像。</p><ol><li>运行一个 Centos 容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d --name centos-01 centos<br></code></pre></td></tr></table></figure><ol start="2"><li>进入到容器中</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it centos-01 /bin/bash<br></code></pre></td></tr></table></figure><ol start="3"><li>配置镜像地址</li></ol><p>请读者先执行下面的命令来确认自己的安装的 centos 版本，以免耗时，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/redhat-release<br></code></pre></td></tr></table></figure><p>我的输出如下所示，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CentOS Linux release 8.4.2105<br></code></pre></td></tr></table></figure><p>因为 Centos 8 官方结束了生命周期，所以默认容器是无法连接到 yum 仓库的，我们需要用到阿里云提供的 CentOS 过期源（centos-vault），</p><p>点进去过期源链接，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904163555764.png" style="zoom:33%;" /><p>接下来自然就是执行对应的 CentOS 8 命令来修改源啦，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">minorver=8.5.2111<br>sed -e &quot;s|^mirrorlist=|#mirrorlist=|g&quot; \<br>         -e &quot;s|^#baseurl=http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.aliyun.com/centos-vault/$minorver|g&quot; \<br>         -i.bak \<br>         /etc/yum.repos.d/CentOS-*.repo<br></code></pre></td></tr></table></figure><p>替换完毕之后让 yum 重新生成缓存，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum makecache<br></code></pre></td></tr></table></figure><p>至此如果你没有出现任何错误那么这个镜像源就配置好啦。</p><ol start="4"><li>安装工具</li></ol><p>因为我们之后会需要用到 wget，vim 工具，所以这里用 yum 快速安装一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y wget vim<br></code></pre></td></tr></table></figure><ol start="5"><li>配置 JDK 环境</li></ol><p>这里以配置 JDK 17 环境为例，我们在容器内拉取 JDK 安装包，</p><p><a href="https://www.oracle.com/java/technologies/downloads/#java17">https://www.oracle.com/java/technologies/downloads/#java17</a></p><p>选择对应 linux 的架构，因为我的电脑是 mac ARM 架构，所以我选择了 “Arm 64 Compressed Archive”。</p><p>在 opt 下创建两个子目录，一个用来放置压缩包，另一个方式安装的软件。然后将 JDK 压缩包下载到 software，然后解压到 module。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/software /opt/module &amp;&amp; cd /opt/software<br>wget https://download.oracle.com/java/17/latest/jdk-17_linux-aarch64_bin.tar.gz // 记得替换为你对应架构的下载链接，我这里是 ARM 架构的<br></code></pre></td></tr></table></figure><p>解压，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf jdk-17_linux-aarch64_bin.tar.gz -C /opt/module/<br>cd /opt/module/<br>mv jdk-17.0.4.1/ jdk/  // 这里可以给 JDK 目录换个名字<br></code></pre></td></tr></table></figure><p>接下来不用我说啦，自然是配置 JDK 环境变量啦，为了方便，我直接贴一个脚本在这里，读者可以直接使用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /etc/profile.d/my_env.sh<br>echo &quot;export JAVA_HOME=/opt/module/jdk&quot; &gt;&gt; /etc/profile.d/my_env.sh<br>echo &quot;export PATH=\$PATH:\$JAVA_HOME/bin&quot; &gt;&gt; /etc/profile.d/my_env.sh<br></code></pre></td></tr></table></figure><p>生效变量，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>检查 java 环境是否已经配置好了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java --version<br></code></pre></td></tr></table></figure><ol start="6"><li>配置 Kafka 环境</li></ol><p>配置完 JDK 的环境我们就来配置 Kafka 的环境，到 Kafka 下载页选择对应的版本然后复制其链接</p><p><a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p><p>同样的还是将压缩包下载到 software 目录下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://downloads.apache.org/kafka/3.2.1/kafka_2.13-3.2.1.tgz /opt/software/<br></code></pre></td></tr></table></figure><p>解压到 module 目录下并重名，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf kafka_2.13-3.2.1.tgz -C /opt/module/ &amp;&amp; mv /opt/module/kafka_2.13-3.2.1 /opt/module/kafka<br></code></pre></td></tr></table></figure><p>添加环境变量，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;export KAFKA_HOME=/opt/module/kafka&quot; &gt;&gt; /etc/profile.d/my_env.sh<br>echo &quot;export PATH=\$PATH:\$KAFKA_HOME/bin&quot; &gt;&gt; /etc/profile.d/my_env.sh<br>source /etc/profile<br></code></pre></td></tr></table></figure><ol start="7"><li>测试 Kafka 是否能够正常运行</li></ol><p>启动 Kafka，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zookeeper-server-start.sh $KAFKA_HOME/config/zookeeper.properties &gt; zookeeper.log &amp;<br>kafka-server-start.sh $KAFKA_HOME/config/server.properties &gt; kafka.log &amp;<br></code></pre></td></tr></table></figure><p>创建一个 Topic，名为 test</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-topics.sh --create --topic test --bootstrap-server localhost:9092<br></code></pre></td></tr></table></figure><p>输出如下为成功创建 topic，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Created topic test.<br></code></pre></td></tr></table></figure><p>创建生产者，并通过 console 向其生产消息，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-producer.sh --topic test --bootstrap-server localhost:9092<br></code></pre></td></tr></table></figure><p>输入并回车来生产消息，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904191159943.png" alt="image-20220904191159943" style="zoom:50%;" /><p>Control + C 退出后，启动消费者，从 Offset 的起始点开始消费消息，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-consumer.sh --topic test --bootstrap-server localhost:9092 --from-beginning<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904191341538.png" alt="image-20220904191341538" style="zoom:50%;" /><p>可以看到 Kafka 能正常生产和消费，那么代表我们的 Kafka 是正常运作的。接下来我们把上述构建的容器打包为镜像，方便我们构建多个实例，从而实现 Kafka 集群。</p><ol start="8"><li>将容器打包为镜像</li></ol><p>先把启动的 Kafka 和 Zookeeper 关闭，通过 JPS 可以看到当前容器内运行的 Java 进程，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904192008273.png" alt="image-20220904192008273" style="zoom:50%;" /><p>输出的信息中，左边为进程号，右边为进程名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 [pid]<br></code></pre></td></tr></table></figure><p>打包为镜像，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit [换成你的容器id] [镜像名称]:[TAG（可以理解为版本号）]<br></code></pre></td></tr></table></figure><p>比如我的容器 id 为 037a32830c16，所以我制作镜像的命令如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit 037a32830c16 centos_kafka:1.0<br></code></pre></td></tr></table></figure><p>执行命令后等待片刻将会看到镜像出现在你本地的镜像列表中，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904193150075.png" alt="image-20220904193150075" style="zoom: 33%;" /><h3 id="4-2-Dockerfile"><a href="#4-2-Dockerfile" class="headerlink" title="4.2 Dockerfile"></a>4.2 Dockerfile</h3><p>虽然经常使用 Linux 命令会对个人能力有提升，但我们如果希望快速部署到服务器上，导出镜像后上传到服务器上很明显是一件不现实的事情，因为我们的镜像有接近 1.2 GB。</p><p>通过编写 Dockerfile 可以将上述的过程写成一个命令文件，然后拷贝到任意安装了 Docker 的主机进行镜像构建。本文不详细介绍 Dockerfile 的内容，网上有非常多优秀的 Dockerfile 教程，读者可以自行搜索，下面我直接给出上述流程的 Dockerfile 版本吧。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> minorver=8.5.2111 \</span><br><span class="language-bash">&amp;&amp; sed -e <span class="hljs-string">&quot;s|^mirrorlist=|#mirrorlist=|g&quot;</span> \</span><br><span class="language-bash">         -e <span class="hljs-string">&quot;s|^#baseurl=http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.aliyun.com/centos-vault/<span class="hljs-variable">$minorver</span>|g&quot;</span> \</span><br><span class="language-bash">         -i.bak \</span><br><span class="language-bash">         /etc/yum.repos.d/CentOS-*.repo \</span><br><span class="language-bash">        &amp;&amp; yum install -y wget vim</span><br><br><span class="hljs-comment"># 配置 JDK 环境，J</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /opt/software /opt/module &amp;&amp; <span class="hljs-built_in">cd</span> /opt/software \</span><br><span class="language-bash"><span class="hljs-comment"># JDK 的链接换为与你设备匹配的版本</span></span><br>        &amp;&amp; wget https://download.oracle.com/java/<span class="hljs-number">17</span>/latest/jdk-<span class="hljs-number">17</span>_linux-aarch64_bin.tar.gz \<br><span class="hljs-comment"># 别忘了换路径</span><br>        &amp;&amp; tar -zxvf jdk-<span class="hljs-number">17</span>_linux-aarch64_bin.tar.gz -C /opt/module/ \<br>&amp;&amp; cd /opt/module/ \<br>&amp;&amp; mv jdk-<span class="hljs-number">17.0</span>.<span class="hljs-number">4.1</span>/ jdk/ \<br>&amp;&amp; touch /etc/profile.d/my_env.sh \<br>&amp;&amp; echo <span class="hljs-string">&quot;export JAVA_HOME=/opt/module/jdk&quot;</span> &gt;&gt; /etc/profile.d/my_env.sh \<br>&amp;&amp; echo <span class="hljs-string">&quot;export PATH=\$PATH:\$JAVA_HOME/bin&quot;</span> &gt;&gt; /etc/profile.d/my_env.sh<br><br><span class="hljs-comment"># 配置 Kafka 环境</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /opt/software/ \</span><br><span class="language-bash">      &amp;&amp; wget https://downloads.apache.org/kafka/3.2.1/kafka_2.13-3.2.1.tgz \</span><br><span class="language-bash">&amp;&amp; tar -zxvf /opt/software/kafka_2.13-3.2.1.tgz -C /opt/module  \</span><br><span class="language-bash">        &amp;&amp; <span class="hljs-built_in">mv</span> /opt/module/kafka_2.13-3.2.1 /opt/module/kafka \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export KAFKA_HOME=/opt/module/kafka&quot;</span> &gt;&gt; /etc/profile.d/my_env.sh \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=\$PATH:\$KAFKA_HOME/bin&quot;</span> &gt;&gt; /etc/profile.d/my_env.sh \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">source</span> /etc/profile</span><br></code></pre></td></tr></table></figure><p>请注意，Dockerfile 中有部分地方你需要注意，因为设备的不同你可能要做适当的修改。</p><p>将上述内容保存为名为 Dockerfile 的文件，然后在其目录下执行 build 命令即可构建镜像，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t kafka_file:v1 .<br></code></pre></td></tr></table></figure><blockquote><p>上述 Dockerfile 还有很多优化空间，但是为了让读者更加容易理解文件所做的工作和手动是差不多的，这里不做优化。读者可以自己尝试优化上述文件，将可以大幅优化文件空间。</p></blockquote><h2 id="5-搭建-Kafka-集群"><a href="#5-搭建-Kafka-集群" class="headerlink" title="5. 搭建 Kafka 集群"></a>5. 搭建 Kafka 集群</h2>]]></content>
    
    
    <categories>
      
      <category>Tool 杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码与艺术——从 COLA 到“打扫厕所”（上）</title>
    <link href="/2022/08b6a1389.html"/>
    <url>/2022/08b6a1389.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我新开的“代码与艺术”专栏，事实上它和艺术沾不上边，反而是要做一些“打扫厕所的脏活儿”，但是分享的内容可能对防治软件退化有着重要的作用，毕竟及时打扫厕所才不会让厕所臭到不敢有人上厕所。</p><p>本节我分享的主要内容不是 COLA 架构，但是却是我几个月从 COLA 中学习到的治理业务代码的方法，并且我已经在一些项目中将这些方法落地，所得到的成效也是十分显著的。</p><p>COLA 项目访问链接：<a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a></p><h2 id="大多数-MVC-或“DDD”架构的现有问题"><a href="#大多数-MVC-或“DDD”架构的现有问题" class="headerlink" title="大多数 MVC 或“DDD”架构的现有问题"></a>大多数 MVC 或“DDD”架构的现有问题</h2><p>目前我见过的大多数工程都是习惯使用以下的几种结构，</p><p><strong>MVC 架构图</strong></p><p>在前后端分离的时代，View 的作用可能被慢慢忘记了。目前大多数 MVC 架构的工作过程是 Controller 完成请求参数的接收和校验，Service 层接受 Controller 层传入的数据并调用数据访问对象来完成业务逻辑，复杂一些的应用架构可能会使用 RPC 来调用其他服务来进行数据交互。这个架构看上去可能没什么问题，大家似乎都是这样做的。下面我先介绍上述应用架构或大多数同学的使用的问题。</p><h3 id="常见业务逻辑代码"><a href="#常见业务逻辑代码" class="headerlink" title="常见业务逻辑代码"></a>常见业务逻辑代码</h3><p>在改善之前我们的业务逻辑中残渣着这样的业务逻辑，我以“IM 发送消息”这个业务的 Mybatis 简单示例（真实情况可能更复杂），</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(String content, Long sessionID, Long senderID, Long reciverID)</span> &#123;<br>    <span class="hljs-comment">// 调用第三方内容安全对发送内容进行检查</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSafe</span> <span class="hljs-operator">=</span> contentChecker.check(content, Sence.CHAT);<br><br>    <span class="hljs-comment">// 检查用户是否存在</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectByID(senderID);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应用户不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否存在</span><br>    <span class="hljs-type">ChatSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> chatSessionMapper.selectByID(sessionID);<br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应会话不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否被关闭（封禁或对方拉黑）</span><br>    <span class="hljs-keyword">if</span> (session.isClosed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;检查是否被对方封禁&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新 session 未读计数</span><br>    <span class="hljs-type">SessionMeta</span> <span class="hljs-variable">sessionMeta</span> <span class="hljs-operator">=</span> sessionMetaMapper.selectByID(session.getID());<br>    sessionMeta.setUnreadCount(sessionMeta.getUnreadCount());<br>    <span class="hljs-keyword">if</span> (!sessionMetaMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 消息存库</span><br>    <span class="hljs-type">SessionMsg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionMsg</span>();<br>    msg.setID(idGenerator.get());<br>    msg.setSessionID(sessionID);<br>    msg.setSender(senderID);<br>    msg.setReciver(reciverID);<br>    msg.setContent(content);<br>    <span class="hljs-keyword">if</span> (!sessionMsgMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 投递 Kafka，让消费者推送 WebSocket</span><br>    <span class="hljs-type">KafkaMsg</span> <span class="hljs-variable">kafkaMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaMsg</span>();<br>    pushMsg.setTopic(TOPIC_PREFIX + userID);<br>    pushMsg.setMsg(content);<br>    kafkaMsgSender.push(kafkaMsg);<br><br>    <span class="hljs-comment">// 推送微信通知</span><br>    <span class="hljs-type">WechatSubMsg</span> <span class="hljs-variable">subMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatSubMsg</span>();<br>    subMsg.setUserID(reciverID);<br>    subMsg.setMsg(content);<br>    wechatApiProvider.pushMsg(subMsg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不仅仅是 Spring Boot-Mybatis 这样一种情况，事实上大多数 Web 开发都存在这样一种编码习惯</p></blockquote><p>相信不少同学的业务逻辑像我上面那样编写，那这样写有什么问题呢？对于小的项目或者小的业务功能时可能并无不妥，但是随着需求的变更，这里面可能会插入越来越多的业务逻辑，这样不断增长的“克苏鲁”将会造成以下问题。</p><h3 id="业务逻辑“消失”，认知成本升高"><a href="#业务逻辑“消失”，认知成本升高" class="headerlink" title="业务逻辑“消失”，认知成本升高"></a>业务逻辑“消失”，认知成本升高</h3><p>正如你所看见的，你不仔细阅读我的分支条件、数据库操作、与Kafka或者推送系统的交互，你很难明白我这一段代码的逻辑流程。我们都知道大多数业务逻辑都是存在一个业务流程的，但是当我们落实到编码的时候，业务逻辑被掩盖了。其他同学想要通过阅读我们的代码来搞懂我们的业务逻辑变得不那么容易，也就是“认知成本”变得很高。</p><h3 id="技术复杂度✖️业务复杂度"><a href="#技术复杂度✖️业务复杂度" class="headerlink" title="技术复杂度✖️业务复杂度"></a>技术复杂度✖️业务复杂度</h3><p>在当前后端的发展形势，我们的代码不仅要处理业务需求，还要处理如 MyBatis 等开发框架，Kafka等中间件，微服务架构等架构带来的技术复杂性。两个复杂性会导致我们的后端可维护性随着需求的变更快速下降。同时还会给项目带来技术风险，假如 MyBatis 框架出现了重大漏洞，要将 MyBatis 换为 Spring Data JDBC，那么我们的业务逻辑代码也需要变更，造成我们的技术变更成本高昂，无法快速应对技术风险！</p><h2 id="结构化分解与组合方法模式"><a href="#结构化分解与组合方法模式" class="headerlink" title="结构化分解与组合方法模式"></a>结构化分解与组合方法模式</h2><p>正如我们在面向过程语言中</p><h2 id="反转-Domain-和-Infrastructure-的依赖关系"><a href="#反转-Domain-和-Infrastructure-的依赖关系" class="headerlink" title="反转 Domain 和 Infrastructure 的依赖关系"></a>反转 Domain 和 Infrastructure 的依赖关系</h2><h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><p>大多数应用架构会选择这样的分层，</p><ul><li>domain</li><li>infrastructure</li></ul><p>大多数应用架构采取的依赖关系如下所示，</p><p>Controller -&gt; Service -&gt; DAO</p><p>Facade -&gt; Application -&gt; Domain -&gt; Infrastructure</p><p>事实上这种依赖方向是存在问题，主要的问题在于领域对象层 Domain 依赖于基础设施层，会使我们的业务代码夹杂着访问基础设施的代码，无法将技术与业务复杂度分离。</p><h3 id="COLA-的做法"><a href="#COLA-的做法" class="headerlink" title="COLA 的做法"></a>COLA 的做法</h3><p>COLA 通过在 Domain 中引入一个 <strong>Gateway</strong> 的概念，</p><ul><li>domain<ul><li>gateway</li></ul></li><li>infrastructure<ul><li>gatewayImpl</li></ul></li></ul><p>对于上面的代码，我们使用 Gateway 来重构一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(String content, Long sessionID, Long senderID, Long reciverID)</span> &#123;<br>    <span class="hljs-comment">// 调用第三方内容安全对发送内容进行检查</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSafe</span> <span class="hljs-operator">=</span> contentChecker.check(content, Sence.CHAT);<br><br>    <span class="hljs-comment">// 检查用户是否存在</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectByID(senderID);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应用户不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否存在</span><br>    <span class="hljs-type">ChatSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> chatSessionMapper.selectByID(sessionID);<br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应会话不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否被关闭（封禁或对方拉黑）</span><br>    <span class="hljs-keyword">if</span> (session.isClosed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;检查是否被对方封禁&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新 session 未读计数</span><br>    <span class="hljs-type">SessionMeta</span> <span class="hljs-variable">sessionMeta</span> <span class="hljs-operator">=</span> sessionMetaMapper.selectByID(session.getID());<br>    sessionMeta.setUnreadCount(sessionMeta.getUnreadCount());<br>    <span class="hljs-keyword">if</span> (!sessionMetaMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 消息存库</span><br>    <span class="hljs-type">SessionMsg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionMsg</span>();<br>    msg.setID(idGenerator.get());<br>    msg.setSessionID(sessionID);<br>    msg.setSender(senderID);<br>    msg.setReciver(reciverID);<br>    msg.setContent(content);<br>    <span class="hljs-keyword">if</span> (!sessionMsgMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 投递 Kafka，让消费者推送 WebSocket</span><br>    <span class="hljs-type">KafkaMsg</span> <span class="hljs-variable">kafkaMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaMsg</span>();<br>    pushMsg.setTopic(TOPIC_PREFIX + userID);<br>    pushMsg.setMsg(content);<br>    kafkaMsgSender.push(kafkaMsg);<br><br>    <span class="hljs-comment">// 推送微信通知</span><br>    <span class="hljs-type">WechatSubMsg</span> <span class="hljs-variable">subMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatSubMsg</span>();<br>    subMsg.setUserID(reciverID);<br>    subMsg.setMsg(content);<br>    wechatApiProvider.pushMsg(subMsg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将贫血模型过渡到充血模型"><a href="#将贫血模型过渡到充血模型" class="headerlink" title="将贫血模型过渡到充血模型"></a>将贫血模型过渡到充血模型</h2><h3 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h3><h3 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h3><h2 id="使用边界上下文"><a href="#使用边界上下文" class="headerlink" title="使用边界上下文"></a>使用边界上下文</h2><h2 id="改善示例"><a href="#改善示例" class="headerlink" title="改善示例"></a>改善示例</h2>]]></content>
    
    
    <categories>
      
      <category>代码与艺术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一起来学Go——CGO极简教程（上）</title>
    <link href="/2022/084f01b598.html"/>
    <url>/2022/084f01b598.html</url>
    
    <content type="html"><![CDATA[<p>本文旨在让使用 Go 语言做开发的同学通过简单的几十分钟快速掌握 Cgo 的使用，本文将会跳过复杂的底层原理介绍及不常用的功能，如果读者在阅读中遇到什么问题，可以在评论区留言。</p><h2 id="放在前面的故事"><a href="#放在前面的故事" class="headerlink" title="放在前面的故事"></a>放在前面的故事</h2><h3 id="初见-C"><a href="#初见-C" class="headerlink" title="初见 C"></a>初见 C</h3><p>简单和我的朋友们介绍一下我与C&#x2F;C++的爱恨情仇。熟悉我的朋友知道，我是高三学习的 Java，对于我而言 Java 是我进入计算机世界的第一门语言。我是在大一学院开设的“C语言程序设计”这门课上学习到了C语言，那时候我写C语言有一股“OOP的味道”～。</p><p>有了 Java 的基础学习 C 会非常快，那时候我很乐于帮助大家解决程序设计中的各种问题，尤其是“空指针”问题。（如图所示）</p><p><img src="https://img-blog.csdnimg.cn/20210302235059216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t1a2Vvbw==,size_16,color_FFFFFF,t_70" alt="C语言指针【“空指针”传参问题】_Kukeoo的博客-CSDN博客_空指针传入函数"></p><p>那时候最让我有成就感的事情就是帮助同学们解决一个又一个 C 语言空指针问题，无论代码长短，无论代码写得怎么样，只要有空指针，我就能快速定位问题并给予解决建议。那段时间也是我非常快乐的时间。</p><h3 id="步入-Android"><a href="#步入-Android" class="headerlink" title="步入 Android"></a>步入 Android</h3><p>大一的时候，由于学 Android 的人比较少，所以当时我加入的项目组基本都有开发 Android App 的需求，于是我在里边写各种各样的 App。</p><p>那时候 Flutter Dart 或 Jetpack Compose 还没有现在那么热门（这里感慨一下客户端市场变化速度之快），当时 Android 开发的主要语言就是 Java。但是 Java 的垃圾回收特性无法满足一些需求场景，比如视频流推拉，视频流处理等。当时我在 Android 平台上遇到的两大问题如下，</p><ul><li>尝试用 Java 进行视频转码，帧率高的时候引发 OutOfMemory</li><li>视频流推拉 GC 过于紧张造成 App 卡顿，手机发热，偶尔遇到 OutOfMemory</li></ul><p>当时对于第一个问题，我最后的解决方案是通过编写 C&#x2F;C++ 动态链接库，以及通过 JNI 进行调用。</p><p>对于第二个问题，我直接使用了 bilibili 站开源的 ijkPlayer 解决了，其中用到了开源的动态链接库，给你们看看我当时写的用来控制小车的 App 吧～</p><blockquote><p>ijkPlayer开源地址：<a href="https://github.com/bilibili/ijkplayer.git">https://github.com/bilibili/ijkplayer.git</a></p></blockquote><h3 id="CGO-之旅"><a href="#CGO-之旅" class="headerlink" title="CGO 之旅"></a>CGO 之旅</h3><p>大二开始我就逐渐回到云计算的阵营，主要往后端、区块链方面靠。于是 Android 成为了我手中的“玩具”，如果有人需要我就偶尔拿出来用一下。C&#x2F;C++ 的应用似乎在我的视野中慢慢淡出。</p><blockquote><p>为了不忘记 Android 这门“手艺”，我自己总结了一套敏捷开发方法论，之后抽空写一篇文章会分享大家</p></blockquote><p>最近遇到一些需求，要用 C&#x2F;C++ 来封装一些 Go 的代码，实现加速和技术封装。不仅让我发现 Cgo 这个非常高效的特性，也让我重新拾回了遗落的点滴～，那么废话不说了，开始我们的 CGo 之旅吧！</p><h2 id="CGO-简介"><a href="#CGO-简介" class="headerlink" title="CGO 简介"></a>CGO 简介</h2><p>Cgo 是 Go 语言自带的工具，来支持 C 语言的函数调用。Cgo 的主要目的是兼容 C&#x2F;C++ 庞大的软件资产。相较于其他语言的 C 本地调用功能，譬如 Java 的 JNI，Python 的 ctypes，CGO 具备简单易用的特性。</p><h2 id="Hello-CGO"><a href="#Hello-CGO" class="headerlink" title="Hello CGO"></a>Hello CGO</h2><p>废话不多说，直接上代码，看一个最简单的 Go 调用 C 的 <code>printf</code> 函数，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void callPrintf()&#123;</span><br><span class="hljs-comment">   printf(&quot;%d&quot;, 666);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   C.callPrintf()<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以试试看，运行结果如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wiki">666<br></code></pre></td></tr></table></figure><p>这就是一个最简单的 CGO 示例了，有几个地方需要介绍一下。</p><h3 id="1-import-“C”"><a href="#1-import-“C”" class="headerlink" title="1. import “C”"></a>1. import “C”</h3><p>这是 CGO 的基础语法，是打开跨语言大门的钥匙，任何 Go 与 C 之间的调用、参数转换等等，都需要通过这个导入这个虚拟的包 “C”。关于 import “C” 有以下几点说明，</p><ul><li><p>import “C” 需要独立一行，不能使用 Go 的批量导入语句</p></li><li><p>import “C” 上方的注释（无论单行、多行），会被当作 C 语言的代码</p><blockquote><p>import “C” 和代码不能有空行</p></blockquote></li><li><p>任何与 C 语言的交互都需要通过导入的虚拟的包 “C”</p></li></ul><p>在上面的示例中，我们在 import “C” 上方导入了著名的 stdio.h 包，然后编写了一个打印 666 的 <code>callPrintf()</code> 函数。除了使用 “C” 和我们自定义的 C 函数交互之外，我们还可以用它和库函数交互，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//#include &quot;call.c&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   C.callPrintf()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2. 类型转换"></a>2. 类型转换</h3><h4 id="整数类型转换"><a href="#整数类型转换" class="headerlink" title="整数类型转换"></a>整数类型转换</h4><p>如果我们希望传参给 C 函数，也需要通过“万能”的 “C”，看如下示例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void add(int a, int b)&#123;</span><br><span class="hljs-comment"> printf(&quot;%d&quot;, a + b);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br>import <span class="hljs-string">&quot;C&quot;</span><br>func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 C.int 我们成功将 Go 数值转化为 C 语言 int 类型的参数。如果我们希望从 C 函数接收返回值，可以参考如下示例，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">int add(int a, int b)&#123;</span><br><span class="hljs-comment"> return a + b;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>res = (<span class="hljs-type">int</span>)(C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>)))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果从 C 函数接收返回参数，有几种方法，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种方式，无需强制类型转换，但是如果下游需要使用该变量，可能还是需要强制类型转换</span><br>res := C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>))<br><span class="hljs-comment">// 第二种方式，直接强制类型转换，具体转换规则看下文</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>res = (<span class="hljs-type">int</span>)(C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>)))<br></code></pre></td></tr></table></figure><blockquote><p>大多数情况下，如果缺少强制转换，将会如下的错误，</p><p>cannot use (Cfunc_add)(Ctype_int(2), _Ctype_int(3)) (value of type _Ctype_int) as type int in assignment</p></blockquote><p>至此，你已经完成了 CGO 的 Hello World 了！但是我相信你肯定还有一堆疑问，请看下文我为你慢慢介绍。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>本节，我们着重介绍 CGO 的类型转换，解决了类型转换问题，事实上就将 CGO 中 80% 以上交互问题。</p><h3 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h3><p>下面讲解第一类比较特殊的转换，字符串的转换了，下面我们以“将传入的字符串转换为大写“为例编写了一个 CGo 程序，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">char* toUpperCase(char* str, int len)&#123;</span><br><span class="hljs-comment">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">        if(str[i] &lt;= 122 &amp;&amp; str[i] &gt;= 97)&#123;</span><br><span class="hljs-comment">            // 大写转小写</span><br><span class="hljs-comment">            str[i] -= 32;</span><br><span class="hljs-comment">        &#125;else if(str[i] &lt;= 90 &amp;&amp; str[i] &gt;= 65)&#123;</span><br><span class="hljs-comment">            // 小写不处理</span><br><span class="hljs-comment">        &#125;else&#123;</span><br><span class="hljs-comment">            // 非字母？</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return str;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Hello World&quot;</span><br>  <span class="hljs-comment">// 转为 C “字符串”</span><br>strC := C.CString(str)<br>  <span class="hljs-comment">// 将返回值转为 GoString</span><br>res := (C.GoString)(C.toUpperCase(strC, C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(str))))<br>fmt.Println(res)<br><span class="hljs-comment">// 记得释放内存 CString 的内存，至于为什么我们之后详解</span><br>C.free(unsafe.Pointer(strC))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们演示了如何<strong>传入字符串参数</strong>和如何<strong>接收字符串返回值</strong>，主要指出两处操作</p><ul><li>通过 C.CString 将 Go string 转换为 C char* 指针，连同长度传入 C 函数</li><li>将 C 函数的返回值强制转换为 Go string</li></ul><p>当然你也可以选择通过 strlen 在 C 语言内获取字符串长度，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;stdlib.h&gt;<br>#include &lt;<span class="hljs-type">string</span>.h&gt;<br>char* toUpperCase(char* str)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = strlen(str);<br>    ... <span class="hljs-comment">// 省略重复代码</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组与切片传递"><a href="#数组与切片传递" class="headerlink" title="数组与切片传递"></a>数组与切片传递</h3><p>切片和数组的传递本质上其实都是<strong>从 Go 传递数组到 C</strong>，看下面的示例就懂啦，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">int sum(int* arr, int len)&#123;</span><br><span class="hljs-comment">int res = 0;</span><br><span class="hljs-comment">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">res += arr[i];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">return res;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []C.<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>res := (<span class="hljs-type">uint</span>)(C.sum(&amp;arr[<span class="hljs-number">0</span>], C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(arr))))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于数组来说我们，我们的传递也比较简单，本质上其实传递数组的地址<code>&amp;arr[0]</code>。</p><blockquote><p>习惯写 C 语言的同学可能会直接传递 arr，加上 IDE 普遍没有 CGO 的补全功能，注意区分 Go 和 C 哈。</p></blockquote><p>那么数组的返回值要怎么接收呢？我并不推荐返回数组给 Go 语言，具体原因请看后续 CGO 的其他文章。</p><h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><p>众所周知 Go 和 C 语言都有结构体类型，那么是不是意味着我们 CGO 的转换也会如此简单呢？</p><p>很遗憾，两者的转换不仅复杂，而且还会有诸多限制，如果要传入结构体类型给 C 函数，那么需要在 Go 语言中使用 C 函数定义的结构体类型，如下示例，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct Data&#123;</span><br><span class="hljs-comment">int data1;</span><br><span class="hljs-comment">float data2;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">float sumData(struct Data d)&#123;</span><br><span class="hljs-comment">return d.data1 + d.data2;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data C.struct_Data<br>  <span class="hljs-comment">// 成员赋值</span><br>  data.data1 = <span class="hljs-number">3</span> <span class="hljs-comment">// C.int(3)</span><br>  data.data2 = <span class="hljs-number">0.14</span> <span class="hljs-comment">// C.float(0.14)</span><br>res := (<span class="hljs-type">float32</span>)(C.sumData(data))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们首先要在 C 语言中预定义该结构体，并在 Go 中声明使用它，各种变量之间的类型转换也需要我们去处理。好在这里 Go 做了处理，不需要我们使用 C.XXX 显式转换。</p><h2 id="令人流泪的坑"><a href="#令人流泪的坑" class="headerlink" title="令人流泪的坑"></a>令人流泪的坑</h2><h3 id="传入的字符串如果中英混合要怎么处理"><a href="#传入的字符串如果中英混合要怎么处理" class="headerlink" title="传入的字符串如果中英混合要怎么处理"></a>传入的字符串如果中英混合要怎么处理</h3><p>众所周知，在 C&#x2F;C++ 中处理中文字符是一件头疼的事情，除了要识别目标主机大小端，还需要处理操作系统的差异。所以我的建议是，非必要不要跨语言传递中英文混合字符串。</p><p>通常来说传递中文字符串是为了获得每个中文字符的 Unicode 并进行一些处理，这里我推荐下面的做法，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void printSlice(int* arr, int len)&#123;</span><br><span class="hljs-comment">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;哈罗沃德&quot;</span><br>runes := []<span class="hljs-type">rune</span>(s)<br>sUCode := <span class="hljs-built_in">make</span>([]C.<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(runes))<br><span class="hljs-comment">// 进行转换</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(runes); i++ &#123;<br>sUCode[i] = C.<span class="hljs-type">int</span>(runes[i])<br>&#125;<br>C.printSlice(&amp;sUCode[<span class="hljs-number">0</span>], C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(sUCode)))<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是将处理中文字符的问题交给 Go 语言的 runes。</p><blockquote><p>如果后续本人有更加好的 CGO 处理方式，将会另开一篇文章</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何发行属于你的代币（NFT、FT）</title>
    <link href="/2022/0737ba805.html"/>
    <url>/2022/0737ba805.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文还在持续更新，更新日期 2022.09.04</p></blockquote><p>你好，我是技术小厨师（Dreamer），欢迎阅读我的区块链专栏，和我一起开始 BlockChain 的学习之旅。我目前在研究区块链与其他行业结合，区块链与分布式机器学习等领域，对区块链有不深不浅的理解。此外，我还具备比较充分的互联网技术知识，我可以从非常多角度为你分析区块链，比如从区块链产业、分布式技术与区块链人文为你介绍区块链。这个专栏致力于为各类人群打造一个容易理解的区块链技术文章，也就是受众不限于区块链兴趣爱好者，区块链从业者，程序员，零基础的区块链门外汉。</p><p>这一篇文章，我想带你感受一下所谓的 NFT 开发到发布上线的流程。相信大家没少听过元宇宙、NFT这些网络热词，但是许多人对 NFT 的印象仅仅是那个被炒到千万美元每平方的虚拟地产。本文侧重于以太坊代币的开发与发行实践，从使用区块链技术开始带大家逐渐走进区块链的世界。希望这篇文章能够让读者能够以短短的半小时就实现区块链上的“hello world”。</p><h2 id="NFT-与-FT"><a href="#NFT-与-FT" class="headerlink" title="NFT 与 FT"></a>NFT 与 FT</h2><p>这节我们先介绍两个概念，一个是同质化代币（Fungible Token），另一个是非同质化代币（Non-Fungible Token），FT 与 NFT 的关系其实和货币与纪念币的关系很像。</p><p>像比特币、以太币这些就是 FT，FT 是具有可计量单位的，比如每个 BTC 或者 ETH 都是相同的，可以互相交换的，这种关系其实和人民币、美元的类似。</p><p>而 NFT 就稍微不一样了，NFT 的关系其实和纪念币的类似，每个纪念币可能有不同的花纹，而每个 NFT 也会有不同的资源，比如图片，电子艺术品，甚至是某种价值等。</p><p>这里给大家看一个有趣的 NFT 项目，首先是以太猫（cryptokitties），以太猫是一个基于以太坊实现的 NFT 游戏，游戏类型是养成。这是它的官网，大家可以点进去看看视频，</p><p><a href="https://www.cryptokitties.co/">https://www.cryptokitties.co/</a></p><p>在这个 NFT 项目中，核心其实就是用 NFT 实现的每个<strong>独一无二的猫咪</strong>，我带大家来看看它的底层数据存储吧，</p><p><a href="https://cn.etherscan.com/token/0x06012c8cf97bead5deae237070f9587f8e7a266d#inventory">https://cn.etherscan.com/token/0x06012c8cf97bead5deae237070f9587f8e7a266d#inventory</a></p><p>我推荐你点开这个链接看看，点开后不要忘记拉到屏幕下方，</p><p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/20220904003530.png"></p><p>可以看到“库存”标签栏中显示了各种各样的图片，图片下方还有一些信息，比如 Token ID。相信你已经猜到了，这些图片及其 Token ID，构成了一个个 NFT，每个猫咪都是独特的，而 Token ID 就是它们在虚拟世界的身份证号。</p><p>看完了 NFT 的项目示例，我本想介绍一个知名的 FT 项目，奈何以太坊没有什么成功的 FT 项目，因为 FT 项目的属性注定了它只能作为一个以太坊智能合约的副产物。在 ETH 的基础之上再弄一个同质化代币实在是没有什么意义。</p><h2 id="准备活动"><a href="#准备活动" class="headerlink" title="准备活动"></a>准备活动</h2><p>可能有读者问，在以太坊上发布一个 NFT 的成本是多少，我可以告诉你，这比上线一个网站要容易得多～。但是要想和区块链交互，我们得首先准备好一些必要的工具。</p><h3 id="1-安装以太坊钱包"><a href="#1-安装以太坊钱包" class="headerlink" title="1. 安装以太坊钱包"></a>1. 安装以太坊钱包</h3><p>别紧张，我们的整个流程都不会触碰到你的真实钱包，区块链钱包狭义上是一个帮你管理区块链账户的工具，广义上其实是区块链的客户端。而要发行 NFT，我们就必须与区块链交互，要和区块链交互就必须要有区块链的客户端。</p><p>这里为了方便，我推荐大家使用 Chrome 浏览器或者 Edge 浏览器来安装一个浏览器钱包，也就是一个浏览器的扩展——MetaMask。你可以在 Chrome 应用商店中中搜索到 <strong>MetaMask</strong> 这个插件。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904010656237.png" alt="image-20220904010656237" style="zoom:25%;" /><p>点进去把它安装好即可到下一步。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904010752498.png" alt="image-20220904010752498" style="zoom: 25%;" /><h3 id="2-配置以太坊钱包"><a href="#2-配置以太坊钱包" class="headerlink" title="2. 配置以太坊钱包"></a>2. 配置以太坊钱包</h3><p>安装好后，可能会弹出一个窗口，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904010918183.png" alt="image-20220904010918183" style="zoom:25%;" /><p>点了同意后，我们就进入了配置钱包的页面，这里我们选择“创建钱包”，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904010954599.png" alt="image-20220904010954599" style="zoom:25%;" /><p>输入密码后点击下一步，将会跳转到如下的界面，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904011157586.png" alt="image-20220904011157586" style="zoom:25%;" /><p>这里简单介绍一下“账户助记词”，“账户助记词”是用于快速恢复钱包的一种方式，你可以通过简单地输入几个单词就可以将你的钱包导入到另一个设备或者软件上，当然这个概念我们会在之后的理论中详细为大家讲解。这里读者可以点进去看看，也可以选择“稍后提醒”。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904011527387.png" alt="image-20220904011527387" style="zoom:25%;" /><p>当你跳转到这个界面的时候，恭喜你，你已经成功进入区块链的世界了，你拥有了钱包，虽然它在“以太坊 Ethereum 主网络”上没有💰。但是我会很快让你获得一些 ETH，尽管它不是真实的。</p><h3 id="3-获取以太坊测试链的-ETH"><a href="#3-获取以太坊测试链的-ETH" class="headerlink" title="3. 获取以太坊测试链的 ETH"></a>3. 获取以太坊测试链的 ETH</h3><p>发币到以太坊主网是需要钱的，而且在发布到主网之前，开发者都需要大量的调试和修复。所以以太坊提供了非常多的测试链，这里我推荐使用 Ropsten 测试网络，因为它获得 ETH 的方式也非常简单。</p><p>首先我们先将钱包连接的网络切换到“Ropsten 测试网络”，如果你的 MetaMask 默认没有显示测试网络，点击“显示&#x2F;隐藏”来显示测试网络，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904012552666.png" alt="image-20220904012552666" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904012915763.png" alt="image-20220904012915763" style="zoom: 50%;" /><p>列表显示测试网络时，我们选中“Ropsten 测试网络”即可，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904013149163.png" alt="image-20220904013149163" style="zoom: 25%;" /><p>这时候我们就连接上了 Ropsten 了，我们也看到我们的 RopstenETH 为 0。接下来我们就来获取一些测试用途的 ETH 吧。</p><p>这里提供一个非常方便的 Ropsten 水龙头，<a href="https://faucet.metamask.io/">https://faucet.metamask.io/</a></p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904013512349.png" alt="image-20220904013512349" style="zoom:25%;" /><p>当你点击“request 1 ether from faucet”时，将会跳转到如下 MetaMask 页面，</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904013835266.png" alt="image-20220904013835266" style="zoom:25%;" /><p>网站通过 MetaMask 向你请求连接账户，选中你需要连接的账户，然后点击“下一步”，然后连接即可。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904013512349.png" alt="image-20220904013512349" style="zoom:25%;" /><p>点击上述按钮然后等待片刻，你将会看到账户余额发生变化。</p><blockquote><p>不过这个网站经常遭受 dos，你可能会看到错误，你可以选择下面的另一种方式</p></blockquote><p>当然还有另外一个网站也可以提供测试以太币的获取，<a href="https://faucet.egorfine.com/">https://faucet.egorfine.com/</a></p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904014343626.png" alt="image-20220904014343626" style="zoom:25%;" /><p>你只需要填入你的账户地址即可，账户地址可以在 MetaMask 中复制过来。</p><img src="https://raw.githubusercontent.com/DreamerLWJ/my_picgo/master/img/image-20220904014443666.png" alt="image-20220904014443666" style="zoom:50%;" /><p>好啦，如果你的账户也像我一样增加了 10 rETH，那么恭喜你，成功在以太坊上获得第一笔“数字资产”。是不是很简单？</p><h2 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h2>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal 源码完全解析</title>
    <link href="/2022/0585bdec67.html"/>
    <url>/2022/0585bdec67.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪高超的技术餐</p></blockquote><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><h3 id="1-官方文档解读"><a href="#1-官方文档解读" class="headerlink" title="1. 官方文档解读"></a>1. 官方文档解读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wiki">This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br></code></pre></td></tr></table></figure><p>意思非常简单，<code>ThreadLocal</code> 提供了一个线程本地变量的实现，这些本地变量在初始化的时候会进行拷贝，线程可以通过 <code>get</code> 和 <code>set</code> 方法与其进行交互。</p><h3 id="2-官方示例"><a href="#2-官方示例" class="headerlink" title="2. 官方示例"></a>2. 官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadId</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 这里定义了一个 static 的 threadId </span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 因为 ++ 并不是一个线程安全的操作，所以这里使用了 atomic 的 CAS</span><br>      <span class="hljs-keyword">return</span> nextId.getAndIncrement();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> threadId.get();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官方提供了一个如上所示的示例，<code>ThreadId</code> 类中有一个 <strong>static</strong> 的 <code>ThreadLocal</code> 类型变量，并且重写了其中的 <code>initialValue()</code> 方法，该方法会返回 nextId 的值并且加一。</p><p>由于官方没有提供使用示例，为了更加轻松地理解该类是如何使用 <code>ThreadLocal</code> 工作的，这里作者提供一个如下的使用示例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, 我的第一次输出为：&quot;</span> + ThreadId.get());<br><br>        <span class="hljs-comment">// 休眠一段时间，来混淆调度</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;我是&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, 我的第二次输出为：&quot;</span> + ThreadId.get());<br>      &#125;<br>    &#125;, <span class="hljs-string">&quot;thread-&quot;</span> + i);<br>    thread.start();<br>  &#125;<br><br>  <span class="hljs-comment">// 主线程等待子线程都执行完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读者可以拷贝上面的代码来尝试运行，多次运行输出有所不同，下面是我的其中一次输出，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">我是thread-1, 我的第一次输出为：1<br>我是thread-3, 我的第一次输出为：3<br>我是thread-4, 我的第一次输出为：4<br>我是thread-0, 我的第一次输出为：0<br>我是thread-5, 我的第一次输出为：5<br>我是thread-2, 我的第一次输出为：2<br>// 名为“thread-6”的线程，第一次输出为“6”<br>我是thread-6, 我的第一次输出为：6<br>我是thread-7, 我的第一次输出为：7<br>我是thread-8, 我的第一次输出为：8<br>我是thread-9, 我的第一次输出为：9<br>我是thread-3, 我的第二次输出为：3<br>我是thread-5, 我的第二次输出为：5<br>我是thread-9, 我的第二次输出为：9<br>我是thread-1, 我的第二次输出为：1<br>// 名为“thread-6”的线程，第二次输出为“6”<br>我是thread-6, 我的第二次输出为：6<br>我是thread-4, 我的第二次输出为：4<br>我是thread-8, 我的第二次输出为：8<br>我是thread-7, 我的第二次输出为：7<br>我是thread-0, 我的第二次输出为：0<br>我是thread-2, 我的第二次输出为：2<br></code></pre></td></tr></table></figure><p>我们从输出中很容易看出对于每个线程而言，<strong>其读取的 threadId 的值都是相同的</strong>，这是非常奇妙的地方。</p><p>我们知道，如果把 threadId 的类型换回普通的 <code>Integer</code> 后直接共享，得到的结果可能是每个线程多次读取的值都不相同。</p><p>那 <code>ThreadLocal</code> 是如何帮助我们实现这一点的呢？请看后文分解～</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="1-ThreadLocal-管理的变量存储在哪？"><a href="#1-ThreadLocal-管理的变量存储在哪？" class="headerlink" title="1. ThreadLocal 管理的变量存储在哪？"></a>1. ThreadLocal 管理的变量存储在哪？</h3><p>我们分析一下 ThreadLocal 的 <code>get</code> 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>    ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法的执行步骤，</p><ol><li><p>调用 <code>getMap()</code> 获取 <code>ThreadLocalMap</code> 对象</p></li><li><p>判断 map 是否为空</p><p> 2.1 如果 map 非空则尝试从 map 中获取保存的值</p><p> 2.2 如果值非空则直接返回</p></li><li><p>如果 map 为空则执行 <code>setInitialValue</code> 方法并返回其值</p></li></ol><p>下面我们看看 <code>setInitialValue()</code> 干了什么事情，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    createMap(t, value);<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，该方法调用了 <code>initialValue()</code>，这个方法默认的返回值是 null。在官方示例中，我们重写了它，用于分配给不同的线程分配不同的值。</p><p>接下来的逻辑就是尝试获取 <code>ThreadLocalMap</code>，如果 map 不存在就先创建一个，然后保存 <code>initialValue()</code> 返回的值。</p><h3 id="2-ThreadLocalMap-解析"><a href="#2-ThreadLocalMap-解析" class="headerlink" title="2. ThreadLocalMap 解析"></a>2. ThreadLocalMap 解析</h3><p>从上面的推断中，我们可以知道 <code>ThreadLocal</code> 保存的值本质上是存储在 <code>ThreadLocalMap</code> 类中，**<code>ThreadLocal</code> 实际上是 Map 中的 key**。下面我们来着重分析这个类，下面我们贴上比较核心的一部分代码，也是我们即将分析的代码。</p><blockquote><p>补充精简版代码</p></blockquote><h4 id="如何存储-ThreadLocal-的每一项值——set"><a href="#如何存储-ThreadLocal-的每一项值——set" class="headerlink" title="如何存储 ThreadLocal 的每一项值——set()"></a>如何存储 ThreadLocal 的每一项值——<code>set()</code></h4><p>大多数情况下是我们只关注如何使用 <code>ThreadLocal</code>，那么我们就来分析与存储和获取相关的方法，先来看看 <code>set()</code> 做了哪些工作，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>  <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>  <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>  <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>  <span class="hljs-comment">// path would fail more often than not.</span><br><br>  Entry[] tab = table;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>       e != <span class="hljs-literal">null</span>;<br>       e = tab[i = nextIndex(i, len)]) &#123;<br>    <span class="hljs-keyword">if</span> (e.refersTo(key)) &#123;<br>      e.value = value;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (e.refersTo(<span class="hljs-literal">null</span>)) &#123;<br>      replaceStaleEntry(key, value, i);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>  <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希表的每项格式——Entry"><a href="#哈希表的每项格式——Entry" class="headerlink" title="哈希表的每项格式——Entry"></a>哈希表的每项格式——<code>Entry</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>  <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>  Object value;<br><br>  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>    <span class="hljs-built_in">super</span>(k);<br>    value = v;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，每个 <code>ThreadLocal</code> 的值被保存在每个 <code>Entry</code> 中，其中 key 为 <code>ThreadLocal</code>。</p><h4 id="ThreadLocalMap-是如何创建的——构造方法"><a href="#ThreadLocalMap-是如何创建的——构造方法" class="headerlink" title="ThreadLocalMap 是如何创建的——构造方法"></a>ThreadLocalMap 是如何创建的——构造方法</h4><p>ThreadLocalMap 有两个构造方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>  <span class="hljs-comment">// 计算哈希表的索引位置</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 创建相应的位置</span><br>  table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>  size = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 设置进行 rehash 的阈值</span><br>  setThreshold(INITIAL_CAPACITY);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>  Entry[] parentTable = parentMap.table;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>  setThreshold(len);<br>  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br><br>  <span class="hljs-keyword">for</span> (Entry e : parentTable) &#123;<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>      <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从父 map 中获取值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value); <span class="hljs-comment">//（1）</span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>        <span class="hljs-comment">// 重新计算每个 Entry 的新位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 遇到空的 Entry 就跳过</span><br>          h = nextIndex(h, len);<br>        table[h] = c;<br>        size++;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个构造方法是对构造一个哈希表并向其存入一个值。</p><p>第二个构造方法稍微复杂一些，看上去是将一个 <code>ThreadLocalMap</code> 拷贝到新的 <code>ThreadLocalMap</code>，但我们仔细去看（1）处的 <code>childValue()</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现是直接抛出异常，事实上这个方法交给了 <code>InheritableThreadLocal</code>，这个类是为了解决<strong>线程之间 ThreadLocal 的继承问题</strong>，这个问题我们以后再聊。</p><p>在阅读完本篇文章后，你只需要知道第二个构造方法在大多数场景下不是由你来调用的，它是用于父线程和子线程之间的 ThreadLocal 的继承。</p><h4 id="ThreadLocalMap-的哈希函数好像不太一样？"><a href="#ThreadLocalMap-的哈希函数好像不太一样？" class="headerlink" title="ThreadLocalMap 的哈希函数好像不太一样？"></a>ThreadLocalMap 的哈希函数好像不太一样？</h4><p>我们可以看到在 <code>ThreadLocal</code> 的代码中存在这样的计算方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而 threadLocalHashCode 的值来源如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt;&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>  <br>  <span class="hljs-comment">// nextHashCode 的增长步长</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看到哈希函数所使用的计算值不是 <code>Object</code> 的 <code>hashCode()</code>，而是用一个静态的 <code>AtomicInteger</code> 类型变量和一个固定的步长生成的，为什么要这样设计？</strong></p><p>我们看到 <code>Entry</code> 没有使用 <code>HashMap</code> 中的 <code>Node</code> 红黑树的设计，这是因为 <code>ThreadLocalMap</code> 在大多数场景下，需要保存的值的数量相对固定且离散，不需要专门为了解决哈希冲突而做冲突设计，节省了内存。</p><p><strong>那么为什么不使用 ThreadLocal 的 hashCode 来计算哈希值呢？</strong></p><p>这个问题也很好回答，既然 <code>ThreadLocalMap</code> 从设计之初就没有打算考虑哈希冲突，那自然要从源头上避免哈希冲突的产生，于是 <code>ThreadLocal</code> 选择了自己来生成 nextHashCode，而是通过静态原子变量来统一为每个 <code>ThreadLocal</code> 对象分配 nextHashCode。</p><p>然后为什么使用 0x61c88647 作为增长步长，我们可以做一个小实验来模拟 ThreadLocal 被多次创建的过程，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h2 id="为什么-Entry-要使用弱引用"><a href="#为什么-Entry-要使用弱引用" class="headerlink" title="为什么 Entry 要使用弱引用"></a>为什么 Entry 要使用弱引用</h2><h2 id="ThreadLocal-的应用"><a href="#ThreadLocal-的应用" class="headerlink" title="ThreadLocal 的应用"></a>ThreadLocal 的应用</h2><h3 id="Spring-Security-保存鉴权结果"><a href="#Spring-Security-保存鉴权结果" class="headerlink" title="Spring Security 保存鉴权结果"></a>Spring Security 保存鉴权结果</h3>]]></content>
    
    
    <categories>
      
      <category>爆肝源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分页查询优化</title>
    <link href="/2022/04bbadf61.html"/>
    <url>/2022/04bbadf61.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="分页查询简介"><a href="#分页查询简介" class="headerlink" title="分页查询简介"></a>分页查询简介</h2><p>可以说，如果读者参与过网络应用的开发，分页查询一定是家常便饭了。比如电商商品列表，论坛帖子列表等等。而一般来说，分页查询其实包括以下两种。</p><ul><li>逻辑分页：在用户第一次访问时，将数据全部查出，添加到 Session 中，然后通过页码和页大小查出其中一部分返回给用户。缺点非常明显，如果数据量比较大的话，将耗费大量的内存；如果数据频繁更新，则内存中的数据容易过期，需要频繁更新。</li><li>物理分页：使用数据库自身的分页机制，每一次分页都会去查询数据库。</li></ul><p>本文只重点介绍物理分页及其优化方案。</p><p>常见的分页查询语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> [col1, col2 ...] <span class="hljs-keyword">from</span> [table_name] <span class="hljs-keyword">where</span> cond1 [<span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-keyword">or</span>] cond2 ... limit [<span class="hljs-keyword">offset</span>], [length];<br></code></pre></td></tr></table></figure><p>分页要关注只有两个参数，</p><ul><li><code>offset</code>（可选）：偏移量，指从表第一行开始，可以理解为页起始位。</li><li><code>length</code>：目标行数，可以理解为页大小。</li></ul><p>希望读者注意一点，分页不是指对表的所有行记录进行分页查询，而是<strong>对表中符合条件的所有行记录</strong>进行分页查询。</p><p>当然，如果没有条件或者表中行记录均符合条件的话，那就等价于对表中的所有行记录进行分页查询。</p><blockquote><p>为什么这一点很重要？因为如果认为分页查询的对象是指表中的所有行，那么在后续的阅读中可能会陷入一个问题，</p><p>“为什么 MySQL 不能像数组那样直接定位 offset 的位置，而是一直遍历直到找到符合条件的行记录呢？”</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>假设我们有这样一个场景，某电商系统使用了如下所示的表来存储商品信息，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> good_info<br>(<br>    good_id     <span class="hljs-type">bigint</span>        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">primary</span> key,<br>    good_name   <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    good_desc   <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    state       tinyint       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    create_time <span class="hljs-type">int</span>     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    sell_count  <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">create</span> index good_info_create_time_index<br>    <span class="hljs-keyword">on</span> good_info (create_time <span class="hljs-keyword">desc</span>);<br></code></pre></td></tr></table></figure><p>各个字段的意义如下，</p><ul><li>good_id：商品唯一 id</li><li>good_name：商品名称</li><li>good_desc：商品描述</li><li>state：商品状态，这里假定存在两种状态，正在出售和库存不足</li><li>create_time：发布时间，为了方便后续的测试数据生成，我们使用整数来代替 timestamp 或 datetime</li><li>sell_count：销售量</li></ul><p>我们接下来使用<code>存储过程</code>来给它添加一点点数据，</p><p><strong>定义随机字符串生成函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">int</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> chars_str <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;<br>  <span class="hljs-keyword">declare</span> return_str <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  while i <span class="hljs-operator">&lt;</span> n do<br>      <span class="hljs-keyword">set</span> return_str<span class="hljs-operator">=</span>concat(return_str,<span class="hljs-built_in">substring</span>(chars_str,<span class="hljs-built_in">floor</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>rand()<span class="hljs-operator">*</span><span class="hljs-number">62</span>),<span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">set</span> i<span class="hljs-operator">=</span> i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span> while;<br>  <span class="hljs-keyword">return</span> return_str;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>定义数据生成存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span><br>    definer <span class="hljs-operator">=</span> lwj<span class="hljs-variable">@localhost</span> <span class="hljs-keyword">procedure</span> gen_data(<span class="hljs-keyword">IN</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<br>    WHILE (i <span class="hljs-operator">&lt;=</span> n ) DO<br>      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> good_info (good_id, good_name, good_desc, state, create_time) <span class="hljs-keyword">VALUEs</span> (i, rand_string(<span class="hljs-number">20</span>), rand_string(<span class="hljs-number">50</span>), <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">2</span>) , <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">1000000</span>));<br>            <span class="hljs-keyword">set</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><strong>执行存储过程</strong></p><p>这里作者选择随机生成 1 千万行数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> gen_data(<span class="hljs-number">10000000</span>);<br></code></pre></td></tr></table></figure><p>执行了 28 m 57 s，终于成功生成了 1 千万条测试数据，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204281221643.png"></p><blockquote><p>读者可能会疑惑，为什么不选择其他外部的测试数据生成方法而选择存储过程。的确，外部生成方式更加灵活，但是性能远比存储过程差，存储过程自创建后就编译并存储在MySQL中。</p></blockquote><h2 id="分页查询的问题"><a href="#分页查询的问题" class="headerlink" title="分页查询的问题"></a>分页查询的问题</h2><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>假如我们有以下的这个分页查询语句，我们调整 offset 和 length，统计查询的平均耗时，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit ?, ?;<br></code></pre></td></tr></table></figure><p>如下为测试结果，</p><table><thead><tr><th>offset</th><th>length</th><th>查询耗时（ms）</th></tr></thead><tbody><tr><td>100</td><td>20</td><td>25</td></tr><tr><td>1000</td><td>20</td><td>48</td></tr><tr><td>10000</td><td>20</td><td>809</td></tr><tr><td>100000</td><td>20</td><td>13762</td></tr><tr><td>1000000</td><td>20</td><td>18966</td></tr></tbody></table><p>我们来 <code>explain</code> 一下各个语句，对于 offset 为 10000 及以下的情况如下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="center">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">index</td><td align="left">NULL</td><td align="left">good_info_create_time_index</td><td align="left">4</td><td align="center">NULL</td><td align="left">120</td><td align="left">100</td><td align="left">NULL</td></tr></tbody></table><p>对于 offset 为 100000 及以上的情况如下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">ALL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">9933232</td><td align="left">100</td><td align="left">Using filesort</td></tr></tbody></table><p>可以看到 <code>offset</code> 为 10000 及左右情况下，优化器还是会选择走索引的，但是像 100000 及以上的情况下，优化器会选择全表，这是为什么呢？为了揭晓这个答案我们可以使用 <code>hint</code>（优化器提示）来强制走索引，看看是怎么一回事儿。</p><p>对于 <code>offset</code> 为 100000 的情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info force index(good_info_create_time_index) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>统计结果耗时为 7922ms，这时候是比优化器选择的全表要快的。</p><p>对于 <code>offset</code> 为 1000000 的情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info force index(good_info_create_time_index) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>统计结果耗时为 1m 6s 4ms！</strong></p><p>也就是说，在 <code>offset</code> 比较大的时候优化器会选择全表而不是查询，因为<strong>全表可能会比走索引更加快</strong>。</p><blockquote><p>读者必须知道优化器并不总是精确的，它是一个综合了各项指标的经验机器，所以才会出现 100000 的情况下不走索引。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分页查询的问题本质上其实是 <code>offset</code> 的问题，首先我们要知道分页查询的过程中，SQL 的执行流程。</p><p>SQL 走索引的执行流程如图所示，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204272255961.png" style="zoom:50%;" /><p>在分页查询中，对于每一行来说都要经过以下的过程，</p><ol><li>通过二级索引查找找到对应的行的主键</li><li>通过主键找到对应的行记录</li><li>通过行记录判断该行是否符合 where 条件</li></ol><p>也就是说，默认的分页查询中会产生非常多次数的回表查询，<code>offset</code> 为 10000，<code>length</code> 为 20 的情况下，SQL 走索引至少要回表查询 10020 次。</p><p>在表中的数据量日渐庞大的情况下，回表查询的代价也是不断上升的，<strong>最终会导致分页走索引的代价比全表查询要高</strong>，所以优化器才会在 <code>offset</code> 较大的情况下选择走全表而不是索引。</p><h2 id="优化分页查询的思路"><a href="#优化分页查询的思路" class="headerlink" title="优化分页查询的思路"></a>优化分页查询的思路</h2><h3 id="id-范围查询"><a href="#id-范围查询" class="headerlink" title="id 范围查询"></a>id 范围查询</h3><p>理想状态下，如果读者想要优化的表具备以下特点，则可以使用 <strong>id 范围查询</strong>来直接定位到需要的数据页范围，</p><ul><li>主键是严格自增的</li><li>表中的数据一经 insert，就不会 delete 的</li><li>主键列不会被修改</li></ul><p>优化前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>耗时 13762ms</p><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-keyword">between</span> <span class="hljs-number">1000000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1000020</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>耗时 10ms，简直是质的飞跃啊！explain 一下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">range</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">NULL</td><td align="left">21</td><td align="left">100</td><td align="left">Using where; Using filesort</td></tr></tbody></table><p>进一步，因为 id 总是自增的，所以后发布的商品其 id 总是更加大一些，所以如果我们可以根据 good_id 来进行排序，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-keyword">between</span> <span class="hljs-number">1000000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1000020</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> good_id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>explain 一下就发现 Extra 中的 <code>filesort</code> 变成为了 <code>Backward index scan</code>。</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">range</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">NULL</td><td align="left">21</td><td align="left">100</td><td align="left">Using where; Backward index scan</td></tr></tbody></table><p>这两者效率有什么不同？简单来说，filesort 需要做一次额外的排序工作，而 Backward index scan 利用了<strong>主键列索引双向链表</strong>直接获得排序后的结果，无需额外的排序工作。</p><blockquote><p>InnoDB 主键列 B+ 树叶子结点按照主键的大小升序排序，而我们的查询要求降序排序，于是查询会使用叶子结点双向链表倒序扫描来获取结果。</p></blockquote><h3 id="标签法"><a href="#标签法" class="headerlink" title="标签法"></a>标签法</h3><p><strong>id 范围查询</strong>的条件是非常理想的，如果服务有分布式的需求的话，可能会将 id 变更为分布式一致性 id，比如雪花 id 等。在这种情况下主键就不是严格自增的了，也就无法使用上述的 <strong>id 范围查询</strong>来优化。本节介绍的标签法则也是一种比较好的方法，能克服上述问题。</p><p>标签法利用历史分页记录来实现，结合了实际的应用场景，我们想象一下在社交论坛列表或者电商商品列表中，用户的行为总是向下滑。换言之，这些场景下的分页查询中，用户请求总是请求”下一页“。</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204281514618.png" style="zoom:50%;" /><p>于是，我们可以用另外的表记录用户的“上一页”的位置，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_page<br>(<br>    user_id     <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">primary</span> key,<br>    next_offset <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><ul><li>user_id：用户的业务 id</li><li>next_offset：该用户下一次分页查询的起始位置</li></ul><p>然后在分页查询的时候使用“历史”表，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-operator">&gt;=</span> (<span class="hljs-keyword">select</span> next_offset <span class="hljs-keyword">from</span> user_page <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> ?) limit <span class="hljs-number">20</span>;<br><span class="hljs-keyword">update</span> user_page <span class="hljs-keyword">set</span> next_offset <span class="hljs-operator">=</span> next_offset <span class="hljs-operator">+</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>这里通过子查询得到了下一次分页 good_id 的起始位置，limit 参数只用于指定页大小。每次分页查询结束后，更新下一次用户的起始位置。</p><p>耗时 29 + 16 ms。也是一种非常不错的方案。</p><h3 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h3><p>如果你的表存在非尾部插入、删除中间行和二级索引树叶子节点值经常变动的情况，那么上面的两种办法都是不行的，比如对商品销售量降序分页查询。</p><p>这时候我们就可以采用使用场景最广的分页查询优化方案——延迟关联。</p><p>所谓延迟关联，其实就是为了避免分页的每一行都进行回表查询，而是通过一种办法一次性找到需要行后再进行回表查询。下面直接给出延迟关联的查询语句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> good_info <span class="hljs-keyword">as</span> g1 <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> good_id <span class="hljs-keyword">FROM</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> LIMIT <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>) <span class="hljs-keyword">as</span> g2 <span class="hljs-keyword">on</span> g1.good_id <span class="hljs-operator">=</span> g2.good_id<br></code></pre></td></tr></table></figure><p>耗时：135 ms</p><p>explain 一下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left">&lt;derived2&gt;</td><td align="left">NULL</td><td align="left">ALL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">1000020</td><td align="left">100</td><td align="left">NULL</td></tr><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left">g1</td><td align="left">NULL</td><td align="left">eq_ref</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">g2.good_id</td><td align="left">1</td><td align="left">100</td><td align="left">NULL</td></tr><tr><td align="left">2</td><td align="left">DERIVED</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">index</td><td align="left">NULL</td><td align="left">good_info_create_time_index</td><td align="left">4</td><td align="left">NULL</td><td align="left">1000020</td><td align="left">100</td><td align="left">Using index</td></tr></tbody></table><p>我们可以看到，自查询中使用了<strong>覆盖索引</strong>来获取符合条件的 good_id，再通过 good_id 去查询主键树来得到结果。最终回表查询次数缩减为页大小，也就是 20 行。</p><blockquote><p>如果一个索引包含（覆盖）我们所需要查询的所有字段值，我们就称之为<strong>覆盖索引</strong>。比如 create_time 的索引树叶子结点存在我们需要的主键的值，那么子查询就不需要回表查询。</p></blockquote><p>其实还有一种<strong>子查询优化</strong>的方法，和延迟关联的思路其实是一样的，都是减少回表查询次数，这里不再赘述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分页查询的优化是非常重要的， 对于线上系统来说，差的分页查询将会成为系统的瓶颈。而本文只从 MySQL 层面谈及了分页查询的多种优化方法，还有一类通过外部缓存实现的分页查询优化，我们以后有机会再说。如果你觉得我写得还不错，可以为点赞和关注～～</p>]]></content>
    
    
    <categories>
      
      <category>MySQL优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EMQX 的集群搭建</title>
    <link href="/2022/04ac35f1ae.html"/>
    <url>/2022/04ac35f1ae.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="上文回顾"><a href="#上文回顾" class="headerlink" title="上文回顾"></a>上文回顾</h2><p>在上文，我们介绍了 EMQX 的快速上手体验，本文将会延续上文的基础继续介绍 EMQX 的集群搭建。</p><h2 id="EMQX-集群配置"><a href="#EMQX-集群配置" class="headerlink" title="EMQX 集群配置"></a>EMQX 集群配置</h2><p>按照之前的基础，我们已经为 192.168.100.100 搭建了一个 EMQX，现在我们可以利用 Linux 集群分发机制实现在 192.168.100.101 和 192.168.100.102 上快速部署 EMQX。</p><p>如果不清楚如何使用集群分发机制，可以参考下面的文章，</p><p>下面我们只需要使用之前的集群分发脚本，将 emqx 的环境配置与安装目录同步到集群 centos 中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">syncall /etc/profile.d/my_emqx.sh<br>syncall /opt/module/emqx/<br></code></pre></td></tr></table></figure><p>这样对于其他的主机来说，emqx 就已经安装好了，接下来我们就进入集群设置环境。</p><blockquote><p>可能需要让环境变量生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure></blockquote><h2 id="static-集群"><a href="#static-集群" class="headerlink" title="static 集群"></a>static 集群</h2><p>static 集群是通过预先存储在各节点的 EMQX 节点的节点列表来实现集群的发现，配置方法较为简单，我们到 192.168.100.100 的节点配置文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件在安装目录下的 etc/emqx.conf</span><br>vim /opt/module/emqx/etc/emqx.conf<br></code></pre></td></tr></table></figure><p>修改文件内容如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改集群模式为 static</span><br>cluster.discovery = static<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置节点发现列表</span><br>cluster.static.seeds = emqx@192.168.100.100,emqx@192.168.100.101,emqx@192.168.100.102<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置节点名称，请注意，节点标识必须和上面节点发现列表中的一致，否则将无法实现集群节点发现</span><br>node.name = emqx@192.168.100.100<br></code></pre></td></tr></table></figure><p>保存后，我们就已经成功修改了 192.168.100.100 的节点集群配置，利用集群分发将配置拷贝到其他节点后，我们只需要修改 192.168.100.101 和 192.168.100.102 配置文件中的节点名称即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">101</span><br>node.name = emqx@192.168.100.101<br><span class="hljs-meta prompt_"># </span><span class="language-bash">102</span><br>node.name = emqx@192.168.100.102<br></code></pre></td></tr></table></figure><p>现在让我们启动集群中的每个节点，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx restart<br></code></pre></td></tr></table></figure><p>进入控制台，看看效果如何，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405185135385.png" alt="image-20220405185135385"></p><p>可以看到在不同的节点上，监控界面显示的节点数如图所示，说明集群已经启动。</p><h2 id="验证集群发布与订阅"><a href="#验证集群发布与订阅" class="headerlink" title="验证集群发布与订阅"></a>验证集群发布与订阅</h2><p>我们如果要进一步验证集群功能是否正常，其实也非常简单，我们来测试跨节点的发布订阅功能，</p><p>现在让我们使用 MQTTX 工具对 192.168.100.100 节点进行订阅，订阅的主题是 testtopic，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405190541047.png" alt="image-20220405190541047"></p><p>现在我们使用另外一个连接，连接到 192.168.100.101 节点，并向 testtopic 发送消息。</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405191115474.png" alt="image-20220405191115474"></p><p>可以看到另外一个连接收到了消息，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405191145030.png" alt="image-20220405191145030"></p><h2 id="配置-Nginx-网关"><a href="#配置-Nginx-网关" class="headerlink" title="配置 Nginx 网关"></a>配置 Nginx 网关</h2><p>集群搭建完后，我们的工作并没有结束，我们需要一个提供一个外部的统一的入口。集群通常是部署在内网的，不具备外网 IP，即使外网 IP 可知，让客户端一次性保存所有节点的 IP 也是不现实的，因为节点可能动态横向扩展并。除此之外，我们需要平衡客户端的访问流量，也就是需要做负载均衡。</p><p>本节我们选择用 Nginx 来作为 EMQX 集群的网关，最终搭建的效果如下所示，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220405205839.png"></p><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>方便起见我们直接这样安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y nginx<br></code></pre></td></tr></table></figure><blockquote><p>读者如果出现 No package nginx available，说明需要配置 epel 源，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install epel-release <br></code></pre></td></tr></table></figure></blockquote><p>启动 nginx，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure><p>验证 nginx 是否启动成功，访问 <a href="http://192.168.100.100,如果显示以下页面,或者/">http://192.168.100.100，如果显示以下页面，或者</a> nginx 首页，则说明 nginx 正常运行，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405212714044.png" alt="image-20220405212714044"></p><h3 id="配置-nginx-负载均衡"><a href="#配置-nginx-负载均衡" class="headerlink" title="配置 nginx 负载均衡"></a>配置 nginx 负载均衡</h3><p>如果你是通过 yum 安装 nginx，则配置文件位置为 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf，因为对 emqx 进行反向代理本质上是对 websocket 进行反向代理，我们还需要安装一个插件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install nginx-mod-stream -y<br></code></pre></td></tr></table></figure><h4 id="SSL-证书的-nginx-负载均衡配置（推荐）"><a href="#SSL-证书的-nginx-负载均衡配置（推荐）" class="headerlink" title="SSL 证书的 nginx 负载均衡配置（推荐）"></a>SSL 证书的 nginx 负载均衡配置（推荐）</h4><p>准备 SSL 证书，如果你只是想要进行尝试，可以申请阿里云免费 SSL 证书，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406141533852.png" alt="image-20220406141533852"></p><p>作者将证书上传到了 &#x2F;etc&#x2F;nginx&#x2F;cert 目录内。</p><p>于是在 nginx 配置文件中，我们添加以下配置，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">stream</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 轮询负载均衡配置</span><br>  <span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 max_fails=2 fail_timeout=30s;</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">      # 监听 8883 端口 SSL</span><br>      <span class="hljs-attr">listen</span> <span class="hljs-string">8883 ssl;</span><br><span class="hljs-comment">      # 反向代理到 emqx_cluster</span><br>      <span class="hljs-attr">proxy_pass</span> <span class="hljs-string">emqx_cluster;</span><br>      <span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br>      <span class="hljs-attr">ssl_handshake_timeout</span> <span class="hljs-string">15s;</span><br><span class="hljs-comment">      # 证书配置</span><br>      <span class="hljs-attr">ssl_certificate</span>     <span class="hljs-string">/etc/nginx/cert/nginx.pem;</span><br>      <span class="hljs-attr">ssl_certificate_key</span> <span class="hljs-string">/etc/nginx/cert/nginx.key;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="不带-SSL-的-nginx-负载均衡配置（不推荐）"><a href="#不带-SSL-的-nginx-负载均衡配置（不推荐）" class="headerlink" title="不带 SSL 的 nginx 负载均衡配置（不推荐）"></a>不带 SSL 的 nginx 负载均衡配置（不推荐）</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">stream</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 轮询负载均衡配置</span><br>  <span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 max_fails=2 fail_timeout=30s;</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">      # 监听 8883 端口 SSL</span><br>      <span class="hljs-attr">listen</span> <span class="hljs-string">8883;</span><br><span class="hljs-comment">      # 反向代理到 emqx_cluster</span><br>      <span class="hljs-attr">proxy_pass</span> <span class="hljs-string">emqx_cluster;</span><br>      <span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Nginx-重载配置并验证负载均衡"><a href="#Nginx-重载配置并验证负载均衡" class="headerlink" title="Nginx 重载配置并验证负载均衡"></a>Nginx 重载配置并验证负载均衡</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><p>随便打开其中一个节点的 Dashboard，看看集群是否正常运作，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142355321.png" alt="image-20220406142355321"></p><p>使用 MQTTX 创建 4 个相同的连接，指向 mqtts:&#x2F;&#x2F;192.168.100.100:8883，即 nginx 网关所在的服务节点，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142625110.png" alt="image-20220406142625110"></p><p>连上四个连接后再次查看 Dashboard，验证负载均衡是否生效，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142909550.png" alt="image-20220406142909550"></p><p>可以看到 4 个连接通过轮询的负载均衡策略被分配到了 3 个节点，至此我们就建立了如下所示的生产集群。</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220406143939.png"></p><h3 id="其他负载均衡策略"><a href="#其他负载均衡策略" class="headerlink" title="其他负载均衡策略"></a>其他负载均衡策略</h3><p>在实际生产中，我们除了简单的轮询负载均衡策略之外，我们还有许多选择，我们只需要修改上面的 upstream 配置即可，</p><p><strong>随机轮询策略</strong></p><p>随机轮询就是从待选列表中随机分配连接，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br>  <span class="hljs-attr">random;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>带权轮询策略</strong></p><p>如果部署的服务器存在性能差异，我们可以通过配置权重 weight 来修改轮询的几率，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 weight=1;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 weight=2;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 weight=3;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>least_conn 策略</strong></p><p>最小连接数策略，优先分配给获得连接数较少的服务器，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br>  <span class="hljs-attr">least_conn;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>IP Hash 策略</strong></p><p>如果有特殊需求，希望同一个客户端连接至同一个服务器，则可以使用 IP Hash 策略。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">  # 指定策略为 ip hash</span><br>  <span class="hljs-attr">ip_hash;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>其他策略</strong></p><p>上面介绍的都是 Nginx 内置的负载均衡策略，其实还有许多通过第三方插件引入的负载均衡策略，比如 fair 等，本文不做过多介绍。</p>]]></content>
    
    
    <categories>
      
      <category>EMQX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EMQX 快速上手（MQTT协议）</title>
    <link href="/2022/04bd0309d7.html"/>
    <url>/2022/04bd0309d7.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="EMQX-介绍"><a href="#EMQX-介绍" class="headerlink" title="EMQX 介绍"></a>EMQX 介绍</h2><p>EMQX 是基于 Erlang&#x2F;OTP 平台开发的开源物联网 MQTT 消息服务器。而 MQTT 实际上是一种应用层协议，用于实现轻量的、发布订阅式的物联网消息协议。事实上，虽然 EMQX 的定位是物联网消息协议 MQTT 的 broker，但是它的处理能力已经超过了它的定义。而在之后的文章中，我们会为读者介绍使用 EMQX 来实现 IM 的推送系统。</p><blockquote><p>本文受限于篇幅，不介绍 MQTT 协议</p></blockquote><h2 id="安装-EMQX"><a href="#安装-EMQX" class="headerlink" title="安装 EMQX"></a>安装 EMQX</h2><p>这里为了方便起见，我们只介绍压缩包安装，也方便利用我们前面所提到的 Centos 集群发布机制，</p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><p>首先我们打开下面的网站，</p><p><a href="https://www.emqx.com/zh/try?product=broker">https://www.emqx.com/zh/try?product=broker</a></p><p>然后我们选择我们对应的版本信息，然后下载压缩包即可，下载完成后进行解压即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip emqx-4.4.2-otp24.1.5-3-el7-amd64.zip<br></code></pre></td></tr></table></figure><p>emqx 目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx/<br>├── bin # 可执行文件的位置<br>├── data # 存放数据的位置<br>├── dynlibs<br>├── erts-12.1.5<br>├── etc # 配置文件位置及插件配置文件位置<br>├── lib<br>├── log # 日志存放位置<br>└── releases<br></code></pre></td></tr></table></figure><h3 id="添加到全局环境变量（可选）"><a href="#添加到全局环境变量（可选）" class="headerlink" title="添加到全局环境变量（可选）"></a>添加到全局环境变量（可选）</h3><p>如果读者不太了解 Centos 的环境变量怎么配置，则可以使用下面的脚本修改执行即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export EMQX_HOME=#读者 EMQX 的安装位置<br>echo &quot;PATH=\$PATH:$EMQX_HOME\bin&quot; &gt; /etc/profile.d/my_emqx.sh<br></code></pre></td></tr></table></figure><p>比如读者的 EMQX 安装位置为 &#x2F;opt&#x2F;module&#x2F;emqx，则对应脚本替换如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export EMQX_HOME=/opt/module/emqx<br>echo &quot;PATH=\$PATH:$EMQX_HOME/bin&quot; &gt; /etc/profile.d/my_emqx.sh<br></code></pre></td></tr></table></figure><p>接下来就是让环境变量生效即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h3 id="启停命令使用"><a href="#启停命令使用" class="headerlink" title="启停命令使用"></a>启停命令使用</h3><p>对于中间件，我们上手的使用方法肯定无非就是启动，停止，重启啦。</p><blockquote><p>如果读者没有添加环境变量，那么之后的执行命令，读者都应该以绝对或者相对路径来指明 emqx 可执行文件的位置，譬如下列命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./emqx start<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/module/emqx/bin/emqx start<br></code></pre></td></tr></table></figure></blockquote><p>下面我们尝试启动 emqx，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx start<br></code></pre></td></tr></table></figure><p>启动成功后，应该看到输出包含以下内容，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">EMQ X Broker x.x.x is started successfully!<br></code></pre></td></tr></table></figure><p>当修改了配置文件或者其他原因需要重新启动 EMQX 时，使用以下命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx restart<br></code></pre></td></tr></table></figure><p>重启成功后，应该看到输出包含以下内容，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">EMQ X Broker 4.4.2 is stopped: ok<br>EMQ X Broker 4.4.2 is started successfully!<br></code></pre></td></tr></table></figure><p>如果要停止 emqx，可以使用以下命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx stop<br></code></pre></td></tr></table></figure><h3 id="控制台使用"><a href="#控制台使用" class="headerlink" title="控制台使用"></a>控制台使用</h3><p>在启动了 emqx 后，我们可以通过访问 18083 端口来使用控制台，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220404222346716.png" alt="image-20220404222346716"></p><p>其默认的账号密码为 admin 和 public。</p><p>进入到 EMQX 后，我们可以首先将语言改为中文，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220404222735198.png" alt="image-20220404222735198"></p><p>下面我们来介绍一下 EMQX dashboard 的各项功能吧。</p><ul><li>监控：查看当前运行节点的各项指标</li><li>客户端：查看已经连接的客户端</li><li>主题：查看当前活动的主题</li><li>订阅：查看当前的客户端与主题的订阅情况</li><li>规则引擎：用SQL构建用于消息流的实时处理，本文不做介绍</li><li>统计分析：主题的消息流入流出统计信息</li><li>插件：这里提供了许多 EMQX 的附加功能，本文后续将会使用其中几个插件</li><li>模块</li><li>工具：主要包含 EMQX HTTP API 和 WebSocket 即时功能，其中 WebSocket 是一个基于浏览器的 MQTT 客户端工具</li><li>告警：用于显示一些威胁到 EMQX 稳定运行的事件，比如主机剩余内存告急，CPU 荷载过高等信息。</li><li>通用：这里包含一些用户管理相关功能，一些端口使用的有效信息。</li></ul><h2 id="MQTTX-客户端"><a href="#MQTTX-客户端" class="headerlink" title="MQTTX 客户端"></a>MQTTX 客户端</h2><p>有了 MQTT broker 还不够，我们还需要一个好用的 MQTT Client，那么这个这里推荐官方提供的客户端 MQTTX，</p><p><a href="https://mqttx.app/zh">https://mqttx.app/zh</a></p><p>安装完成后，界面如下所示，使用方法非常简单，点击左侧 + 按钮，即可创建连接，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220405013816.png" style="zoom: 50%;" /><p>其连接的高级功能本文不做介绍，里面涉及一些 MQTT 协议的内容，如果读者了解 MQTT 协议，自然理解里面的一些设置的含义。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>作者使用它来连接到本地的 192.168.100.100 虚拟机中的 EMQX，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014144463.png" alt="image-20220405014144463" style="zoom: 67%;" /><p>点击连接后，如果连接成功将会显示如下的内容，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014447704.png" alt="image-20220405014447704" style="zoom: 50%;" /><h3 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h3><p>现在我们再创建一个连接，用来测试之后的订阅与发布功能。现在我们两个连接都已经连接上了 EMQX，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014810255.png" alt="image-20220405014810255" style="zoom:50%;" /><p>我们通过“添加订阅”功能为两个连接添加同一个订阅，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015208192.png" alt="image-20220405015208192" style="zoom:50%;" /><p>现在我们通过其中一个连接给主题 test- topic 发送消息，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015353716.png" alt="image-20220405015353716" style="zoom:50%;" /><p>我们可以看到另一个连接接收到了新的消息，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015436618.png" alt="image-20220405015436618" style="zoom:50%;" /><p>至此有关 MQTTX 的介绍到此为止。</p>]]></content>
    
    
    <categories>
      
      <category>EMQX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高效配置 Centos 集群环境</title>
    <link href="/2022/0413e8bb0e.html"/>
    <url>/2022/0413e8bb0e.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p><p>⚠ 本文较长，请分期食用，注意实践与理论结合</p><p>图片挂了，呜呜呜～，请各位看客转为阅读公众号文章，</p><p><a href="https://mp.weixin.qq.com/s/IWE9rZ1JzF6tr_uqQKWzCg">https://mp.weixin.qq.com/s/IWE9rZ1JzF6tr_uqQKWzCg</a></p><p>图片晚点补上。</p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在刚拿到服务器的时候，第一个问题就是环境配置。作为一个 Javaer，给新机器配置 JDK 和搭建中间件集群已经是家常便饭的事情了。配置工作是机械的，但是往往因为网络等因素而变得耗时，那有没有一劳永逸的办法呢？本文将为你揭晓答案。</p><h2 id="2-环境与前提条件"><a href="#2-环境与前提条件" class="headerlink" title="2. 环境与前提条件"></a>2. 环境与前提条件</h2><p>本文将会带读者快速实现对三台机器的基础环境配置，并且留下一个<strong>手脚架和实践方法</strong>以供读者配置其他环境使用。</p><ul><li>Windows 11</li><li>VMware Workstation 16</li></ul><p>在这里需要读者准备好 Centos 镜像和 JDK linux 压缩包</p><ul><li>centos：<a href="https://www.centos.org/download/">https://www.centos.org/download/</a></li><li>JDK：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></li></ul><blockquote><p>我的习惯是更加偏向使用压缩包来进行安装，因为压缩包的好处就是安装位置由自己选择，方便统一管理</p></blockquote><h2 id="3-配置-Centos-集群"><a href="#3-配置-Centos-集群" class="headerlink" title="3. 配置 Centos 集群"></a>3. 配置 Centos 集群</h2><p>这里我们将选择搭建 3 台虚拟机来模拟真实的服务器集群环境，读者可以选择自己搭建然后直接跳到第 4 节，也可以选择跟着我的节奏来搭建 centos 集群。最终本节搭建成功的效果如图所示，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/1.png"  /><h3 id="3-1-创建一个-centos-虚拟机"><a href="#3-1-创建一个-centos-虚拟机" class="headerlink" title="3.1 创建一个 centos 虚拟机"></a>3.1 创建一个 centos 虚拟机</h3><blockquote><p>如果你已经创建好了，那么你可以选择跳过本节</p></blockquote><ol><li><p>打开新建虚拟机向导，这里我们选择自定义</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/2.png" alt="image-20220320151931689" style="zoom:80%;" /></li><li><p>点击两次下一步后，这里我们选择创建一个空白的虚拟硬盘，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/3.png" alt="image-20220320160448877" style="zoom:80%;" /></li><li><p>这里因为我下载的是 Centos 7 x64 的镜像，所以我的配置如下所示，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/4.png" style="zoom:80%;" /></li><li><p>配置虚拟机名和存放位置，下一步</p></li><li><p>虚拟机配置（处理器和内存配置），如果你不需要使用可视化操作界面的话，可以调低一点。当然，这些配置之后可以修改，所以不用太担心。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/5.png" alt="image-20220320153030516" style="zoom:80%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/6.png" alt="image-20220320153129741" style="zoom:80%;" /></li><li><p>选择 NAT 网络，这对我们之后配置虚拟网络的非常关键，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/7.png" alt="image-20220320153313087" style="zoom:80%;" /></li><li><p>IO 控制器和磁盘类型我们不需要做变动，直接下一步就行</p></li><li><p>磁盘配置，大家可以参考我的配置</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/8.png" alt="image-20220320153454705" style="zoom:80%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/9.png" alt="image-20220320160713489" style="zoom:80%;" /></li><li><p>后面的配置都无关紧要了，如果没有什么需要自定义的地方读者可以选择一直下一步到完成</p></li><li><p>配置操作系统镜像<br>到刚创建好的虚拟机，为其配置操作系统镜像，如图所示，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/10.png" style="zoom:67%;" /></li><li><p>启动虚拟机，完成操作系统设置<br>如果读者使用的镜像也是 centos 7 的话，接下来的步骤基本相同。选择好语言和键盘后将会跳转到当前界面，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/11.png" style="zoom:80%;" /><p>我们接下来要在这个界面完成几项设置，</p><ul><li><p>SOFTWARE SELECTION：软件设置，我的习惯是只安装一个最小的，只有命令交互界面的 centos，如果读者有使用 GUI 界面的习惯可以选择另外一个选项。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/12.png" style="zoom:67%;" /></li><li><p>NETWORK &amp; HOST NAME：配置网络，我们要让 centos 能够连接上网络</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/13.png" style="zoom:67%;" /><p>将如图所示开关打开</p></li></ul><p>上述配置完成后我们选择 Begin Installation，之后会跳转到如图界面，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/14.png" style="zoom:80%;" /><p>按照它的指引配置 Root 密码和用户即可，这里作者配置 root 账号密码为 123456</p></li><li><p>安装完进行一波重启，应该就能进入如图所示的命令交互界面了</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/15.png" alt="image-20220320170832373" style="zoom: 80%;" /></li></ol><h3 id="3-2-配置虚拟网络"><a href="#3-2-配置虚拟网络" class="headerlink" title="3.2 配置虚拟网络"></a>3.2 配置虚拟网络</h3><p>下面我们需要配置虚拟网络，配置的目的主要是为了模拟真实的网络环境，让虚拟机在宿主机上拥有自己的静态 ip，并且虚拟机之间能够成功访问彼此。</p><blockquote><p>如果读者计划使用服务器，而不是本地虚拟机来实践的话，可以选择跳过这一节和后面的 3.4 节，在这两节我们主要做了这些工作，</p><ul><li>配置 NAT 网关</li><li>通过克隆创建了三台虚拟机</li></ul></blockquote><ol><li>点开 Vmware Workstation 的虚拟网络编辑器</li></ol><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/16.png" style="zoom:80%;" /><ol start="2"><li>点击更改设置通过 UAC 管理员设置后将会显示如图界面</li></ol><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/17.png" alt="image-20220322221749684" style="zoom: 67%;" /><ol start="3"><li><p>下面我们添加一个虚拟网络 Vmnet8</p><p>点击添加网络，选择 Vmnet8，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/18.png" alt="image-20220322222445596" style="zoom:67%;" /><p>创建成功后，将会如图显示，我们要做几个配置，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/19.png" alt="image-20220322223213216" style="zoom:67%;" /><p>修改后长这样，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/20.png" alt="image-20220322223532826" style="zoom:67%;" /><p>现在我们点进去 NAT 设置，看看网关地址，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/21.png" alt="image-20220322223640034" style="zoom: 67%;" /><p>一般来说如果你和我使用的是相同的配置，我们的网关地址都是 192.168.100.2，至此虚拟网络就配置好了，别忘了确定保存噢~</p></li></ol><h3 id="3-3-配置模板虚拟机网络"><a href="#3-3-配置模板虚拟机网络" class="headerlink" title="3.3 配置模板虚拟机网络"></a>3.3 配置模板虚拟机网络</h3><p>现在让我们进入之前创建的那台 centos 虚拟机，</p><ol><li><p>修改网络配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><blockquote><p>如果这时候提示 vim command not found，则读者需要通过以下命令安装 vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y vim<br></code></pre></td></tr></table></figure></blockquote><p>我们需要修改配置文件中的几项，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改为 static</span><br><span class="hljs-attr">BOOTPROTO</span>=<span class="hljs-string">static</span><br><span class="hljs-comment">### 如果没有以下几项则添加 ###</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.100 </span><br><span class="hljs-comment"># 指定前缀长度</span><br><span class="hljs-attr">PREFIX</span>=<span class="hljs-string">24 </span><br><span class="hljs-comment"># 指定网关</span><br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-string">192.168.100.2 </span><br><span class="hljs-comment"># 指定 DNS</span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-string">192.168.100.2 </span><br></code></pre></td></tr></table></figure><p>保存后重启虚拟机</p></li><li><p>测试是否已经成功配置网络</p><p>我们在宿主机尝试 ping 配置好的虚拟机 192.168.100.100，如下图所示，可以看到结果如下所示。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/22.png" alt="image-20220322225737162" style="zoom:67%;" /></li></ol><h3 id="3-4-克隆虚拟机"><a href="#3-4-克隆虚拟机" class="headerlink" title="3.4 克隆虚拟机"></a>3.4 克隆虚拟机</h3><p>上面我们创建了一个模板虚拟机，现在我们要用它来创建两个 ip 分别为 192.168.100.101 和 192.168.100.102 的虚拟机</p><ol><li><p>选择克隆菜单</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220322231806931.png" style="zoom:80%;" /></li><li><p>接下来的步骤通过图示演示</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/24.png" style="zoom:67%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/25.png" alt="image-20220322232010039" style="zoom:67%;" /><p>下面配置虚拟机名称和存储位置点击完成即可。</p><ol start="3"><li><p>通过上面的步骤克隆两个虚拟机后，我们只需要将之前的网络配置文件中的静态 IP 地址分别修改即可。这里我们分别修改为 192.168.100.101 和 192.168.100.102</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">...</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.101 </span><br><span class="hljs-attr">...</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">...</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.102</span><br><span class="hljs-attr">...</span><br></code></pre></td></tr></table></figure></li><li><p>配置完成后，重启虚拟机，这时候应该有三台虚拟机正在运行，现在我们要验证三台虚拟机是否能够互通</p><blockquote><p>这里读者使用了 XShell 来作为 SSH 工具，当然实际上直接使用虚拟机的 Terminal 也是没有问题的</p></blockquote><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/26.png" alt="image-20220323141303356" style="zoom: 80%;" /><p>让虚拟机之间互相 ping 一下，看看是否能够联通</p></li></ol></li></ol><h2 id="4-配置-JDK-环境"><a href="#4-配置-JDK-环境" class="headerlink" title="4. 配置 JDK 环境"></a>4. 配置 JDK 环境</h2><p>本节我们首先会配置其中一台虚拟机的环境，这里我们配置 192.168.100.100 的 JDK 环境</p><p>按照作者习惯，一般软件压缩包会放置在 &#x2F;opt&#x2F;software 目录下，而其安装位置选择在 &#x2F;opt&#x2F;module，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/software /opt/module<br></code></pre></td></tr></table></figure><p>进入 software，然后将 JDK 压缩包上传上去，上传成功后我们通过 ll 查看，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/27.png" alt="image-20220323145427597" style="zoom:80%;" /><p>进行解压，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf /opt/software/jdk-8u321-linux-x64.tar.gz -C /opt/module/<br></code></pre></td></tr></table></figure><p>进入解压好的 jdk 目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/module/jdk1.8.0_321/<br></code></pre></td></tr></table></figure><p>pwd，然后复制一下路径，配置环境变量时会用到。</p><p>现在我们进入环境变量目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/profile.d/<br></code></pre></td></tr></table></figure><p>创建一个自定义的脚本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim my_env.sh<br></code></pre></td></tr></table></figure><p>将下面的内容输入到文件中进行保存，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/opt/module/jdk1.8.0_321/<br>export PATH=$PATH:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>使得环境变量生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>检查 Java 环境是否生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><p><img src="C:/Users/11740/AppData/Roaming/Typora/typora-user-images/image-20220324013931610.png" alt="image-20220324013931610"></p><p>这里可能有读者有疑问，为什么不直接修改 &#x2F;etc&#x2F;profile 文件？而是通过在 profile.d 目录下创建一个自己的配置文件。首先，是不推荐大家修改 profile，相较于创建一个专门的文件来管理自定义环境变量，追加式地修改 profile 不容易维护，并且容易修改错误，导致其他系统变量出现问题。然后我们再来分析一下 profile.d 下自定义的文件是如何生效的？</p><h2 id="5-Linux-集群分发介绍"><a href="#5-Linux-集群分发介绍" class="headerlink" title="5. Linux 集群分发介绍"></a>5. Linux 集群分发介绍</h2><h3 id="5-1-SCP-命令介绍"><a href="#5-1-SCP-命令介绍" class="headerlink" title="5.1 SCP 命令介绍"></a>5.1 SCP 命令介绍</h3><p><code>scp</code> 是 secure copy 的简写，用于 linux 下远程文件拷贝的命令，功能和 cp 是类似的，只不过强制使用 SSH 连接加密的方式。通常来说如果不配置服务器之间的免密登录，那么每次使用命令都将需要输入目标服务器的账户密码。</p><p><code>scp</code> 的命令的简单使用格式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r local_path remote_username@remote_ip:remote_path<br></code></pre></td></tr></table></figure><ul><li>local_path：本地文件路径</li><li>remote_username：远程服务器的用户名</li><li>remote_ip：远程服务器 ip 地址</li><li>remote_path：要拷贝到的远程路径</li></ul><p>下面我们简单使用一下，我们尝试使用这条命令从 192.168.100.100 <strong>拷贝</strong> JDK 安装目录到 192.168.100.101，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r /opt/module/ root@192.168.100.101:/opt/module/<br></code></pre></td></tr></table></figure><p>这时候会提示你非对称加密指纹的警告，我们输入 yes 再继续，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/image-20220323225308534.png" style="zoom:80%;" /><p>接下来会提示你需要输入密码才能继续，输入密码回车后，你将会看到一大段输入，和 cp 命令的输出是一个道理的，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/30.png" alt="image-20220323225328417" style="zoom:80%;" /><blockquote><p>重新执行 <code>scp</code> 命令之后还是需要重新输入密码的，这很麻烦，在第六节，作者将会介绍如何配置免密登录</p></blockquote><p>我们到 192.168.100.101 的目录下验证是否已经拷贝成功，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/31.png" alt="image-20220323230539273" style="zoom:80%;" /><p>细心的读者再重复执行一次拷贝命令，会发现 <code>scp</code> 命令会重复完整地拷贝整个 module 并以覆盖的形式传送到指定服务器，我们将会看到和第一次执行 <code>scp</code> 命令一样的输出。换言之，<code>scp</code> 命令无论远程服务器指定目录下是否已经存在相同的文件，<code>scp</code> 都会重复地拷贝，这样带来许多无用的拷贝工作，造成了很多额外的耗时。</p><blockquote><p>事实上，我们希望找到一种类似 SVN 或者 Git 版本控制工具的同步方式，而不需要每一次都进行完整的拷贝，那么接下来介绍的命令将会以一种镜像同步的方式解决集群分发问题。</p></blockquote><h3 id="5-2-RSYNC-命令介绍"><a href="#5-2-RSYNC-命令介绍" class="headerlink" title="5.2 RSYNC 命令介绍"></a>5.2 RSYNC 命令介绍</h3><p><code>rsync</code> 主要用于备份和镜像同步。相较于 <code>scp</code>，它具备速度更快、避免复制相同内容等优点。</p><p><code>rsync</code> 的命令的简单使用格式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av local_path remote_username@remote_ip:remote_path<br></code></pre></td></tr></table></figure><p>现在我们尝试使用 <code>rsync</code> 来将 JDK <strong>同步</strong>到 192.168.100.102，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /opt/module/ root@192.168.100.102:/opt/module/<br></code></pre></td></tr></table></figure><blockquote><p>读者可能需要先安装一下 <code>rsync</code>，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y rsync<br></code></pre></td></tr></table></figure></blockquote><p>第一次执行的前两步和前面的 <code>scp</code> 一样，都是要保存远程服务器的密钥指纹和输入密码，后续执行就只需要输入密码了。</p><p>输入密码回车执行后，由于是第一次同步 module 路径，那么第一次肯定是全量同步的，也就是和拷贝是没有什么去别的。当我们重复执行这条命令后，你会发现和 <code>scp</code> 有所不同，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/32.png" style="zoom:80%;" /><p>命令会很快执行完毕，因为 <code>rsync</code> 使用的是增量同步的方式，由于文件没有经过修改，那么 <code>rsync</code> 不会产生任何文件拷贝操作。</p><p>现在我们尝试同步 &#x2F;etc&#x2F;profile.d&#x2F;my_env.sh 配置文件到其他服务器中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /etc/profile.d/my_env.sh root@192.168.100.101:/etc/profile.d/<br>rsync -av /etc/profile.d/my_env.sh root@192.168.100.102:/etc/profile.d/<br></code></pre></td></tr></table></figure><p>读者将会看到以下输出，</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220323234300219.png" style="zoom:80%;" /><p>现在我们往配置文件中添加一些注释，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Java Home</span><br><span class="hljs-attr">export</span> <span class="hljs-string">JAVA_HOME=/opt/module/jdk1.8.0_321/</span><br><span class="hljs-comment"># add to path</span><br><span class="hljs-attr">export</span> <span class="hljs-string">PATH=$PATH:$JAVA_HOME/bin</span><br></code></pre></td></tr></table></figure><p>再次执行 rsync，只不过这时候我们选择同步整个 profile.d 路径，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /etc/profile.d/ root@192.168.100.101:/etc/profile.d/<br></code></pre></td></tr></table></figure><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/20220323235123.png" style="zoom:80%;" /><p>读者会发现 <code>rsync</code> 只同步了被修改的 <code>my_env.sh</code> 文件，我们也就验证了 <code>rsync</code> 增量同步的特性。这个特性非常有用，加入我们在 &#x2F;opt&#x2F;module 和 &#x2F;etc&#x2F;profile.d 目录下分别放置着非常多的软件目录和配置文件，<strong>rsync 能够帮助我们实现修改一处然后同步到多处的需求</strong>。</p><h3 id="5-3-集群分发脚本"><a href="#5-3-集群分发脚本" class="headerlink" title="5.3 集群分发脚本"></a>5.3 集群分发脚本</h3><p>通过上面我们介绍了 rsync 命令的使用，在使用中我们发现一个问题，如果需要同步一个路径到多个服务器时，我们需要执行下面的多条命令，并且<strong>如果需要同步的服务器越多，命令执行的次数就越多，</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av local_path root@192.168.100.101:remote_path<br>rsync -av local_path root@192.168.100.102:remote_path<br>...<br></code></pre></td></tr></table></figure><p>我们能不能有一种一劳永逸的办法，我只需要给命令提供路径，它就自动帮我同步到所有节点呢？那这就是 shell 脚本的命令了，下面提供一个脚本供读者使用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断参数是否足够</span><br>if [ $# -lt 1 ]<br>then<br>    echo Not Enough Arguement!<br>    exit;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">遍历集群所有 ip</span><br>for host in 192.168.100.100 192.168.100.101 192.168.100.102<br>do<br>    echo ====================  $host  ====================<br>    <br>    # 遍历所有目录<br>    for file in $@<br>    do<br>        # 判断文件是否存在<br>        if [ -e $file ]<br>            then<br>                # 获取父目录<br>                pdir=$(cd -P $(dirname $file); pwd)<br>                # 获取当前文件的名称<br>                fname=$(basename $file)<br>                ssh $host &quot;mkdir -p $pdir&quot;<br>                # 循环执行 rsync 命令<br>                rsync -av $pdir/$fname $host:$pdir<br>            else<br>                echo $file does not exists!<br>        fi<br>    done<br>done<br></code></pre></td></tr></table></figure><p>如果读者使用了不同的 ip 地址，则只需要修改脚本这一处为你的 ip 列表，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">...<br>for host in ip1 ip2 ip3 ... ipn<br>...<br></code></pre></td></tr></table></figure><p>下面我们来使用这个脚本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd<br>vim syncall<br></code></pre></td></tr></table></figure><p>然后将上面的脚本写入文件中并保存。</p><p>修改脚本执行权限，使其能够被执行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x syncall<br></code></pre></td></tr></table></figure><p>验证脚本是否能够被执行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./syncall /etc/profile.d/<br></code></pre></td></tr></table></figure><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324001525055.png" alt="image-20220324001525055" style="zoom: 67%;" /><p>可以看到除了要处理密钥指纹和输入多次密码之外，脚本是正常执行的。</p><p>拷贝到 bin 目录以便全局可用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp syncall /bin<br></code></pre></td></tr></table></figure><p>至此你已经能够在任何地方使用这个集群分发脚本了。</p><h2 id="6-SSH-免密登录"><a href="#6-SSH-免密登录" class="headerlink" title="6. SSH 免密登录"></a>6. SSH 免密登录</h2><p>因为篇幅问题，我们不在本文介绍 SSH 免密登录原理，直接提供步骤给大家。</p><ol><li><p>生成本机的公私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd .ssh/<br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>然后直接敲回车，让它做默认选择</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324002139567.png" alt="image-20220324002139567" style="zoom: 67%;" /></li><li><p>拷贝公钥到指定服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id 192.168.100.100<br>ssh-copy-id 192.168.100.101<br>ssh-copy-id 192.168.100.102<br></code></pre></td></tr></table></figure><p>期间会需要输入指定服务器的 root 密码</p><blockquote><p>注意，如果读者希望其他服务器也能互相无密登录，则需要到 101 和 102 的服务器上重复执行上面的步骤。如果读者希望不适用 root 账号来做无密登录，则需要切换到其他用户账户，并重复上面步骤即可。</p></blockquote></li><li><p>使用集群分发来验证是否配置成功</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324002801484.png" alt="image-20220324002801484" style="zoom:80%;" /><p>一路畅通~</p></li></ol><h2 id="7-总结经验"><a href="#7-总结经验" class="headerlink" title="7. 总结经验"></a>7. 总结经验</h2><p>本文核心的内容是 <code>SCP</code> 与 <code>RSYNC</code> 的使用与<strong>集群分发脚本</strong>。经验之谈，如果想要快速配置一台新购买的服务器，那么我建议本地保存有一些常用的模板机，然后通过在远程服务器安装 <code>rsync</code> ，并通过启动模板机做集群分发即可快速完成模板配置。</p>]]></content>
    
    
    <categories>
      
      <category>Tool 杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计数器表</title>
    <link href="/2022/03444975c.html"/>
    <url>/2022/03444975c.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多论坛或者电商系统都具备点赞数、评论数、浏览数等“计数”功能，好的设计可以实现不低并发量且精确的计数器需求。本文将抛开中间件等额外的设计，从 MySQL 出发简单聊聊如何设计计数器表。</p><h2 id="糟糕的设计"><a href="#糟糕的设计" class="headerlink" title="糟糕的设计"></a>糟糕的设计</h2><p>下面以论坛系统为例子介绍其中一种计数器表设计，下面给出这个最简单的设计，我们有这样一个表 post，承担着主要的帖子读写业务，其中一个高频写入功能为帖子的点赞计数功能。</p><table><thead><tr><th>post_id</th><th>post_content</th><th>··· 其他列 ···</th><th>likes</th></tr></thead><tbody><tr><td>1</td><td>## content ##</td><td>···</td><td>3</td></tr><tr><td>2</td><td>## content ##</td><td>···</td><td>5</td></tr><tr><td>3</td><td>## content ##</td><td>···</td><td>2</td></tr><tr><td>···</td><td>···</td><td>···</td><td>···</td></tr></tbody></table><p>这个设计对于并发量很低的系统来说，可能没有什么问题，但是当并发量增加时，点赞的并发性能将会成为系统的瓶颈。</p><blockquote><p>点赞是用户无意识的行为，在社交论坛上，点赞的触发次数远大于其他功能，对点赞计数的优化是非常重要的。</p></blockquote><p>首先我们必须明确，我们增加某个点赞计数时使用的 SQL 语句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> post_id <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><p>我们知道，一个事务在更新某一行时，如果 where 子句使用的是索引，那么该事务需要首先获取该行的互斥锁。多个并发事务想要增加同一个帖子的点赞量时，这种设计将会使得这些事务只能串行执行。如图所示，</p><img src="C:/Users/11740/Desktop/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/1.png"  /><p>如果同一时间出现热门帖子时，多个用户同时点赞将会导致大量的数据库连接处于等待状态。为了优化这种事务串行的问题，我们介绍一种低成本且有效的方案——<strong>计数器表</strong>。</p><h2 id="计数器表优化"><a href="#计数器表优化" class="headerlink" title="计数器表优化"></a>计数器表优化</h2><p>现在我们希望将帖子的点赞计数移到另外的表 post_counter，并且做一些冗余设计。</p><table><thead><tr><th>post_id</th><th>slot</th><th>likes</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>3</td></tr><tr><td>1</td><td>1</td><td>5</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>4</td></tr><tr><td>1</td><td>4</td><td>2</td></tr><tr><td>2</td><td>0</td><td>3</td></tr><tr><td>2</td><td>1</td><td>5</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>3</td><td>6</td></tr><tr><td>2</td><td>4</td><td>3</td></tr><tr><td>···</td><td></td><td>···</td></tr></tbody></table><p>DDL语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> post_counter<br>(<br>    post_id <span class="hljs-type">int</span>              <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    slot    tinyint unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    likes   <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><p>对于每个 post_id，我们<strong>预先创建 5 行数据，同一个 post_id 的不同行用 slot（槽）标识</strong>。如果我们要进行增加点赞数，其 SQL 语句如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post_counter <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> slot <span class="hljs-operator">=</span> rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>相应的减少点赞数如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post_counter <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> slot <span class="hljs-operator">=</span> rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>读者很容易发现，并发事务对同一个帖子的点赞数更新操作将会被随机分散到 5 行数据中，如图所示，</p><img src="C:/Users/11740/Desktop/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/2.png"  /><p>这样能够很好地解决前面所提到的并发事务串行操作的问题。如果我们要获取一个帖子的点赞数，我们只需要做一个聚合查询即可，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(likes) <span class="hljs-keyword">from</span> post_counter <span class="hljs-keyword">where</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p><strong>每个帖子都预先创建 5 行会不会导致表的行数过多？</strong></p><p>我们知道有个帖子可能发出来很长一段时间都没有人点赞，或者点赞数稀少，对于这种情况，预留 5 行会显得比较多余。于是，我们可以选择 update 的时候动态创建，这时候我们可以使用 on duplicate key 子句来解决这个需求。因此新的增加点赞语句如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> post_counter (post_id, likes, slot) <span class="hljs-keyword">values</span>(?, <span class="hljs-number">1</span>, rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span>) <span class="hljs-keyword">on</span> duplicate key <span class="hljs-keyword">update</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>相应的减少点赞数的语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> post_counter (post_id, likes, slot) <span class="hljs-keyword">values</span>(?, <span class="hljs-number">-1</span>, rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span>) <span class="hljs-keyword">on</span> duplicate key <span class="hljs-keyword">update</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了计数器表的设计方法，其适用于各种高频的计数需求。本文为了简单演示，使用的随机数窗口为 5，实际生产中，读者可以通过逐步增加窗口值大小，并通过压力测试来查看锁等待时间，以找到合适当前业务的窗口大小。</p><p>至于有关 Redis 的高并发点赞计数我们以后再聊。不过作者认为，任何优化都应该优先考虑数据库层面的优化，在数据库层面优化没有达标的情况下，通过引入中间件缓存不过是堆积成本的暴力方法罢了。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java序列化源码解析（一）</title>
    <link href="/2022/03cdd3ee69.html"/>
    <url>/2022/03cdd3ee69.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪高超的技术餐</p><p>掘金原文：<a href="https://juejin.cn/post/6987962113788493831">https://juejin.cn/post/6987962113788493831</a> </p></blockquote><h3 id="Java如何得到-suid-的？"><a href="#Java如何得到-suid-的？" class="headerlink" title="Java如何得到 suid 的？"></a>Java如何得到 suid 的？</h3><p>了解过序列化的同学肯定知道，<code>suid</code> 在反序列化时侯有两个，一个是本地类计算出来的 <code>suid</code>，一个是从序列化字节流中读取的 <code>suid</code>，我们的分析也是针对这两种进行展开。</p><h3 id="1-从异常抛出开始"><a href="#1-从异常抛出开始" class="headerlink" title="1. 从异常抛出开始"></a>1. 从异常抛出开始</h3><p>为了寻找源码分析的思路，我们可以通过引发异常开始</p><h4 id="1-1-创建定义一个可序列化的类"><a href="#1-1-创建定义一个可序列化的类" class="headerlink" title="1.1 创建定义一个可序列化的类"></a>1.1 创建定义一个可序列化的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-comment">// getter &amp; setter &amp; toString</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-运行序列化方法"><a href="#1-2-运行序列化方法" class="headerlink" title="1.2 运行序列化方法"></a>1.2 运行序列化方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;player&quot;</span>, <span class="hljs-number">21</span>);<br>    user.setName(<span class="hljs-string">&quot;player&quot;</span>);<br>    user.setAge(<span class="hljs-number">21</span>);<br>    System.out.println(user);<br>    FileSerializeUtil.serialize(user, <span class="hljs-string">&quot;user.obj&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object object, String filepath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filepath))) &#123;<br>        objectOutputStream.writeObject(object);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.warning(<span class="hljs-string">&quot;serialize: fail to serialize object to &quot;</span> + filepath);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-做点手脚"><a href="#1-3-做点手脚" class="headerlink" title="1.3 做点手脚"></a>1.3 做点手脚</h4><p>添加一个成员变量到 User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-运行反序列化方法"><a href="#1-4-运行反序列化方法" class="headerlink" title="1.4 运行反序列化方法"></a>1.4 运行反序列化方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) FileSerializeUtil.deserialize(<span class="hljs-string">&quot;user.obj&quot;</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String filepath)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filepath))) &#123;<br>        <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        logger.warning(<span class="hljs-string">&quot;deserialize: file to deserialize object from &quot;</span> + filepath);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-触发异常，查看异常信息"><a href="#1-5-触发异常，查看异常信息" class="headerlink" title="1.5 触发异常，查看异常信息"></a>1.5 触发异常，查看异常信息</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Exception in thread <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-keyword">java.io.InvalidClassException: </span>serial.User<span class="hljs-comment">; local class incompatible: stream classdesc serialVersionUID = 8985745470054656491, local class serialVersionUID = -4967160969146043535</span><br><span class="hljs-built_in">at</span> <span class="hljs-keyword">java.base/java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:715)</span><br><span class="hljs-keyword"></span>...<br></code></pre></td></tr></table></figure><p>由此我们可以从 715 行开始我们的故事</p><h3 id="2-主干源码分析"><a href="#2-主干源码分析" class="headerlink" title="2. 主干源码分析"></a>2. 主干源码分析</h3><h4 id="2-1-initNonProxy-分析"><a href="#2-1-initNonProxy-分析" class="headerlink" title="2.1 initNonProxy()分析"></a>2.1 <code>initNonProxy()</code>分析</h4><p>为了确定本地的 <code>serialVersionUID</code> 和来自序列化字节流的 <code>serialVersionUID</code> 是如何获得的，在 <code>ObjectStreamClass</code> 类中我们找到了抛出异常的地方，在 <code>initNonProxy()</code> 有这样一段判断代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initNonProxy</span><span class="hljs-params">(ObjectStreamClass model,</span><br><span class="hljs-params">                      Class&lt;?&gt; cl,</span><br><span class="hljs-params">                      ClassNotFoundException resolveEx,</span><br><span class="hljs-params">                      ObjectStreamClass superDesc)</span><br>        <span class="hljs-keyword">throws</span> InvalidClassException<br>    &#123;<br>    <span class="hljs-comment">// (1) suid 的值在这里获得的</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">suid</span> <span class="hljs-operator">=</span> Long.valueOf(model.getSerialVersionUID());<br>    ...<br>        <span class="hljs-keyword">if</span> (cl != <span class="hljs-literal">null</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// 异常在这里抛出</span><br>            <span class="hljs-keyword">if</span> (model.serializable == osc.serializable &amp;&amp;<br>                    !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;<br>                <span class="hljs-comment">// (2) osc 也是通过 getSerialVersionUID() 得到序列化</span><br>                    suid != osc.getSerialVersionUID()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidClassException</span>(osc.name,<br>                        <span class="hljs-string">&quot;local class incompatible: &quot;</span> +<br>                                <span class="hljs-string">&quot;stream classdesc serialVersionUID = &quot;</span> + suid +<br>                                <span class="hljs-string">&quot;, local class serialVersionUID = &quot;</span> +<br>                                osc.getSerialVersionUID());<br>            &#125;<br>            ...<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常产生的原因在于 <code>suid</code> 和 <code>osc.getSerialVersionUID()</code> 不相等。而我们可以知道，两者本质上都调用了 <code>getSerialVersionUID()</code> 方法，我们断定该方法中一定有某种判断。下面我们对 <code>getSerialVersionUID()</code> 方法展开分析。</p><h4 id="2-2-getSerialVersionUID-分析"><a href="#2-2-getSerialVersionUID-分析" class="headerlink" title="2.2 getSerialVersionUID() 分析"></a>2.2 <code>getSerialVersionUID()</code> 分析</h4><p>首先我们注意到方法的文档注释第一行，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Return</span> the serialVersionUID <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">class</span>.<br></code></pre></td></tr></table></figure><p>很显然，告诉我们这个方法返回的类的 <code>serialVersionUID</code> 。我们在源码中 debug 也可以得到 <code>computeDefaultSUID()</code> 返回的即为本地类的 <code>suid</code>，</p><p>该方法的源代码如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSerialVersionUID</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// REMIND: synchronize instead of relying on volatile?</span><br>    <span class="hljs-keyword">if</span> (suid == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isRecord)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br><br>        suid = AccessController.doPrivileged(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Long&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> computeDefaultSUID(cl);<br>                &#125;<br>            &#125;<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> suid.longValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加清楚发现两者调用的不同，我们 debug 看看，</p><p>对于（1）处 <code>suid</code>，</p><p><img src="C:/Users/11740/Desktop/1"></p><p>对于（2）处 <code>osc.getSerialVersionUID()</code> 则有两种可能，</p><ul><li><p><code>User</code> 类中没有自定义 <code>serialVersionUID()</code></p><p><img src="C:/Users/11740/Desktop/2"></p></li><li><p><code>User</code> 类中自定义了 <code>serialVersionUID()</code></p><p><img src="C:/Users/11740/Desktop/3"></p></li></ul><p>我们很容易理解就是<strong>本地序列化类的 UID</strong> 和<strong>反序列化字节流 UID</strong> 都是通过这个方法来获得的。对于<strong>没有自定义的本地的 UID</strong>将会走 if 中的 <code>computeDefaultSUID()</code> 方法进行计算类的 SUID，对于自定义 SUID 和字节流中的 SUID，将会直接返回。</p><blockquote><p>关于 <code>computeDefaultSUID()</code> 的详解可以阅读下文，现在我们先继续讲主线内容</p></blockquote><p>那么我们会有疑问，既然不走 <code>computeDefaultSUID()</code>，那么自定义 SUID 和字节流中的 SUID 是从哪得到的呢？我们通过 IDEA 强大的检索功能，我们可以看看引用了 <code>suid</code> 的地方，</p><p><img src="C:/Users/11740/Desktop/4"></p><p><img src="C:/Users/11740/Desktop/5"></p><ul><li>蓝色标注的是我们<strong>没有自定义 suid 类的计算路径</strong></li><li>目测红色 <code>getDeclaredSUID()</code> 是获取自定义（声明）的 <code>suid</code></li><li>红色 <code>in.readLong()</code> 是从文件输入流中获取的</li></ul><p>下面我们分析获取自定义声明的 <code>suid</code> 来印证我们的猜测。</p><blockquote><p><code>in.readLong()</code> 部分我们不做分析，因为继续进入将会进入 I&#x2F;O 部分的 Java 类，这里简单理解就是通过输入流从文件中读取一个 <code>long</code> 类型整数。</p></blockquote><h4 id="2-3-获取自定义（声明的）suid"><a href="#2-3-获取自定义（声明的）suid" class="headerlink" title="2.3 获取自定义（声明的）suid"></a>2.3 获取自定义（声明的）suid</h4><h5 id="2-3-1-ObjectStreamClass-分析"><a href="#2-3-1-ObjectStreamClass-分析" class="headerlink" title="2.3.1 ObjectStreamClass() 分析"></a>2.3.1 <code>ObjectStreamClass()</code> 分析</h5><p>通过 IDEA 跳转，我们来到了调用 <code>getDeclaredSUID()</code> 的地方，看了看这个方法的注释，</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Creates <span class="hljs-keyword">local</span> <span class="hljs-built_in">class</span> descriptor representing <span class="hljs-keyword">given</span> <span class="hljs-built_in">class</span>.<br></code></pre></td></tr></table></figure><p>大概的意思是，创建一个对应类的描述符。其他的细节我们不需要过分关注，我们只需要关注 if … else 条件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-comment">// 判断是否实现 Serializable 接口    </span><br>serializable = Serializable.class.isAssignableFrom(cl);<br>...<br><span class="hljs-keyword">if</span> (serializable) &#123;<br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            ...<br>            suid = getDeclaredSUID(cl);<br>            ...<br>        &#125;<br>    &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果没有实现 suid = 0</span><br>    suid = Long.valueOf(<span class="hljs-number">0</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出，对于没有实现 <code>Serializable</code> 的类来说，默认分配的 <code>suid</code> 是 0，对于实现了的类来说，走 <code>getDeclaredSUID()</code> 得到 <code>suid</code>。</p><h5 id="2-3-2-getDeclaredSUID-分析"><a href="#2-3-2-getDeclaredSUID-分析" class="headerlink" title="2.3.2 getDeclaredSUID() 分析"></a>2.3.2 <code>getDeclaredSUID()</code> 分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getDeclaredSUID</span><span class="hljs-params">(Class&lt;?&gt; cl)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射得到成员变量 serialVersionUID</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> cl.getDeclaredField(<span class="hljs-string">&quot;serialVersionUID&quot;</span>);<br>        <span class="hljs-comment">// 检查成员变量 serialVersionId 是否是静态常量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> Modifier.STATIC | Modifier.FINAL;<br>        <span class="hljs-keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;<br>            f.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 真正得到本地类自定义 suid 的地方</span><br>            <span class="hljs-keyword">return</span> Long.valueOf(f.getLong(<span class="hljs-literal">null</span>));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法代码并不多，首先通过反射得到成员变量 <code>serialVersionUID</code>，判断其是否是静态常量，然后通过反射得到它的值，就这么简单。看吧，获取自定义（声明）的 <code>suid</code> 已经分析完毕了。</p><h3 id="3-默认计算类-suid-的方法-computeDefaultSUID"><a href="#3-默认计算类-suid-的方法-computeDefaultSUID" class="headerlink" title="3. 默认计算类 suid 的方法 computeDefaultSUID()"></a>3. 默认计算类 suid 的方法 <code>computeDefaultSUID()</code></h3><p>这个方法是在类没有自定义 <code>serialVersionUID</code> 的情况下用于根据类的“信息”来计算 <code>suid</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">computeDefaultSUID</span><span class="hljs-params">(Class&lt;?&gt; cl)</span> &#123;<br>    <span class="hljs-comment">// 检查是否是代理对象和是否是 Serializable 的子类或子接口</span><br>    <span class="hljs-keyword">if</span> (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将输出缓冲到字节数组中</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-comment">// 这里我们可以理解为 dout 将输出缓存到 bout</span><br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bout);<br><br>        <span class="hljs-comment">// 类名写入字节数组</span><br>        dout.writeUTF(cl.getName());<br><br>        <span class="hljs-comment">// 获取类名修饰符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">classMods</span> <span class="hljs-operator">=</span> cl.getModifiers() &amp;<br>            (Modifier.PUBLIC | Modifier.FINAL |<br>             Modifier.INTERFACE | Modifier.ABSTRACT);<br><br>        <span class="hljs-comment">// 获取类成员方法</span><br>        Method[] methods = cl.getDeclaredMethods();<br>        <br>        <span class="hljs-keyword">if</span> ((classMods &amp; Modifier.INTERFACE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果类是接口</span><br>            classMods = (methods.length &gt; <span class="hljs-number">0</span>) ?<br>                <span class="hljs-comment">// 如果存在方法就与抽象修饰符进行或运算</span><br>                (classMods | Modifier.ABSTRACT) :<br>            <span class="hljs-comment">// 不存在方法就与抽象修饰符的反码进行与运算</span><br>                (classMods &amp; ~Modifier.ABSTRACT);<br>        &#125;<br>        <span class="hljs-comment">// 类修饰符写入字节数组</span><br>        dout.writeInt(classMods);<br><br>        <span class="hljs-keyword">if</span> (!cl.isArray()) &#123;<br>            <span class="hljs-comment">// 补偿对于数组的处理，对于数组类型将会得到 Cloneable 和 Serializable，所以数组不必走进来</span><br>            Class&lt;?&gt;[] interfaces = cl.getInterfaces();<br>            String[] ifaceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[interfaces.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interfaces.length; i++) &#123;<br>                ifaceNames[i] = interfaces[i].getName();<br>            &#125;<br>            <span class="hljs-comment">// 对接口名进行排序，避免对于同样的接口数组产生不同的写入</span><br>            Arrays.sort(ifaceNames);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ifaceNames.length; i++) &#123;<br>                <span class="hljs-comment">// 接口名写入字节数组</span><br>                dout.writeUTF(ifaceNames[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取成员变量</span><br>        Field[] fields = cl.getDeclaredFields();<br>        MemberSignature[] fieldSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[fields.length];<br>        <span class="hljs-comment">// 获取成员变量的签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>            fieldSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(fields[i]);<br>        &#125;<br>        Arrays.sort(fieldSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-comment">// 按照成员变量名进行排序</span><br>                <span class="hljs-keyword">return</span> ms1.name.compareTo(ms2.name);<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 对成员变量进行处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> fieldSigs[i];<br>            <span class="hljs-comment">// 得到成员变量修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |<br>                 Modifier.TRANSIENT);<br>            <span class="hljs-comment">// 非私有则进行写入</span><br>            <span class="hljs-keyword">if</span> (((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) ||<br>                <span class="hljs-comment">// 如果是 static 或 transient 则写入</span><br>                ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == <span class="hljs-number">0</span>))<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 也就是说，在这里如果是非私有则一定写入，如果是私有但满足 static 或 transient 才写入</span><br><span class="hljs-comment">                 */</span><br>            &#123;<br>                <span class="hljs-comment">// 签名信息写入字节数组</span><br>                dout.writeUTF(sig.name);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 静态类则写入</span><br>        <span class="hljs-keyword">if</span> (hasStaticInitializer(cl)) &#123;<br>            dout.writeUTF(<span class="hljs-string">&quot;&lt;clinit&gt;&quot;</span>);<br>            dout.writeInt(Modifier.STATIC);<br>            dout.writeUTF(<span class="hljs-string">&quot;()V&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取构造方法</span><br>        Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();<br>        MemberSignature[] consSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[cons.length];<br>        <span class="hljs-comment">// 获取构造方法签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cons.length; i++) &#123;<br>            consSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(cons[i]);<br>        &#125;<br>        <span class="hljs-comment">// 对构造方法签名进行排序</span><br>        Arrays.sort(consSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-keyword">return</span> ms1.signature.compareTo(ms2.signature);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; consSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> consSigs[i];<br>            <span class="hljs-comment">// 获取构造方法修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL |<br>                 Modifier.SYNCHRONIZED | Modifier.NATIVE |<br>                 Modifier.ABSTRACT | Modifier.STRICT);<br>            <span class="hljs-comment">// 如果是非私有构造方法则进行写入</span><br>            <span class="hljs-keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) &#123;<br>                dout.writeUTF(<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature.replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>));<br>            &#125;<br>        &#125;<br><br>        MemberSignature[] methSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[methods.length];<br>        <span class="hljs-comment">// 获取方法的签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>            methSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(methods[i]);<br>        &#125;<br>        <span class="hljs-comment">// 方法签名排序</span><br>        Arrays.sort(methSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">comp</span> <span class="hljs-operator">=</span> ms1.name.compareTo(ms2.name);<br>                <span class="hljs-keyword">if</span> (comp == <span class="hljs-number">0</span>) &#123;<br>                    comp = ms1.signature.compareTo(ms2.signature);<br>                &#125;<br>                <span class="hljs-keyword">return</span> comp;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> methSigs[i];<br>            <span class="hljs-comment">// 获取方法修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL |<br>                 Modifier.SYNCHRONIZED | Modifier.NATIVE |<br>                 Modifier.ABSTRACT | Modifier.STRICT);<br>            <span class="hljs-comment">// 非私有则写入</span><br>            <span class="hljs-keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) &#123;<br>                dout.writeUTF(sig.name);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature.replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 刷新，将结果保存到字节数组</span><br>        dout.flush();<br><br>        <span class="hljs-comment">// 对之前字节数组进行 SHA 运算</span><br>        <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA&quot;</span>);<br>        <span class="hljs-type">byte</span>[] hashBytes = md.digest(bout.toByteArray());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.min(hashBytes.length, <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            hash = (hash &lt;&lt; <span class="hljs-number">8</span>) | (hashBytes[i] &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(ex);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法看上去很长，其实做的事情是重复且容易理解，简单来说就是通过反射获取这个类的各种信息，将它们放到一个字节数组中，然后使用 <code>hash</code> 函数（SHA）进行运算得到一个代表类的“摘要”。这里作者已经充分注释了整个方法，读者可以通过粗略阅读来理解这个方法的具体细节。</p><blockquote><p>hash 函数是一种常用于加密或者生成信息摘要的方法，其特点主要有</p><ul><li>任意输入，固定输出</li><li>防碰撞，也叫做差之毫厘居距之千里，输入哪怕修改了 1 个位，计算出来结果也会发生大变化</li><li>单向性，其实也是任意输入，固定输出所决定的，通过 hash 值反向计算出原来的输入计算上是不可行的</li></ul><p>如果读者对这部分感兴趣，待作者开“区块链”专栏为读者一一介绍“加密的那些事情”</p></blockquote><h4 id="3-1-决定类-suid-的因素"><a href="#3-1-决定类-suid-的因素" class="headerlink" title="3.1 决定类 suid 的因素"></a>3.1 决定类 suid 的因素</h4><p>上面我们知道 hash 函数是产生这个 <code>suid</code> 的关键，那么要找决定 <code>suid</code> 的因素，首先寻找决定 hash 的因素，也就是 hash 的输入，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA&quot;</span>);<br><span class="hljs-comment">// 输入来源</span><br><span class="hljs-type">byte</span>[] hashBytes = md.digest(bout.toByteArray());<br><span class="hljs-type">long</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.min(hashBytes.length, <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    hash = (hash &lt;&lt; <span class="hljs-number">8</span>) | (hashBytes[i] &amp; <span class="hljs-number">0xFF</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到输入来自于 <code>bout</code> 变量，也就是我们要密切关注与下面俩个变量的操作，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 缓存 hash 输入的对象</span><br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-comment">// 方法中往 bout 写入的对象</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bout);<br></code></pre></td></tr></table></figure><p>我们只要找到与 <code>bout</code> 有关的动作就可以，上面作者已经将完整的代码注释了，读者可以阅读后看下面总结因素及引起 hash 值变化的具体动作，</p><table><thead><tr><th>因素</th><th>具体动作</th></tr></thead><tbody><tr><td>类名</td><td>修改类名</td></tr><tr><td>类修饰符</td><td>增加、减少和修改类修饰符</td></tr><tr><td>类接口</td><td>增加、减少和实现接口</td></tr><tr><td>类成员方法和构造方法</td><td>增加和减少方法；修改方法签名</td></tr><tr><td>类成员变量（包括静态、常量）</td><td>增加和减少变量；修改变量签名</td></tr></tbody></table><p>我们发现除了类所继承的类并不影响 <code>suid</code> 之外，其他类信息的变动都将修改类的 <code>suid</code>。</p><blockquote><p>其实这些因素里面还有一些不同的细节，作者已经在源码中标注了，比如对于私有构造方法，并不写入到 hash 输入中。</p><p>至于为什么当初的编写者不将类继承算进去，作者还在思考中</p></blockquote><h4 id="3-1-为什么要进行-Sort？"><a href="#3-1-为什么要进行-Sort？" class="headerlink" title="3.1 为什么要进行 Sort？"></a>3.1 为什么要进行 Sort？</h4><p>在阅读这个方法时，我们不难发现一些地方经常用到 <code>Array.sort()</code> 方法对各种反射得到的变量进行排序，比如下面的这段代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(fieldSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>        <span class="hljs-keyword">return</span> ms1.name.compareTo(ms2.name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这段代码是对反射得到的类成员变量签名进行排序的方法，其实不难理解，目的就是成员变量之间的位置变换不应该影响一个类的 <code>suid</code>，比如我将 <code>User</code> 的两个成员变量位置互换，反序列化也不会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们的序列化源码分析就结束啦，这是作者花了非常大时间去创作的一篇源码分析，如果你喜欢我这样的新人的话，不妨点个赞。如果你觉得我有些地方可以改进，非常希望在评论区看到你哟！</p>]]></content>
    
    
    <categories>
      
      <category>爆肝源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
