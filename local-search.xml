<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码与艺术——从 COLA 到“打扫厕所”（上）</title>
    <link href="/2022/08/18/%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%89%BA%E6%9C%AF%E2%80%94%E2%80%94%E4%BB%8E%20COLA%20%E5%88%B0%E2%80%9C%E6%89%93%E6%89%AB%E5%8E%95%E6%89%80%E2%80%9D%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%89%BA%E6%9C%AF%E2%80%94%E2%80%94%E4%BB%8E%20COLA%20%E5%88%B0%E2%80%9C%E6%89%93%E6%89%AB%E5%8E%95%E6%89%80%E2%80%9D%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我新开的“代码与艺术”专栏，事实上它和艺术沾不上边，反而是要做一些“打扫厕所的脏活儿”，但是分享的内容可能对防治软件退化有着重要的作用，毕竟及时打扫厕所才不会让厕所臭到不敢有人上厕所。</p><p>本节我分享的主要内容不是 COLA 架构，但是却是我几个月从 COLA 中学习到的治理业务代码的方法，并且我已经在一些项目中将这些方法落地，所得到的成效也是十分显著的。</p><p>COLA 项目访问链接：<a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a></p><h2 id="大多数-MVC-或“DDD”架构的现有问题"><a href="#大多数-MVC-或“DDD”架构的现有问题" class="headerlink" title="大多数 MVC 或“DDD”架构的现有问题"></a>大多数 MVC 或“DDD”架构的现有问题</h2><p>目前我见过的大多数工程都是习惯使用以下的几种结构，</p><p><strong>MVC 架构图</strong></p><p>在前后端分离的时代，View 的作用可能被慢慢忘记了。目前大多数 MVC 架构的工作过程是 Controller 完成请求参数的接收和校验，Service 层接受 Controller 层传入的数据并调用数据访问对象来完成业务逻辑，复杂一些的应用架构可能会使用 RPC 来调用其他服务来进行数据交互。这个架构看上去可能没什么问题，大家似乎都是这样做的。下面我先介绍上述应用架构或大多数同学的使用的问题。</p><h3 id="常见业务逻辑代码"><a href="#常见业务逻辑代码" class="headerlink" title="常见业务逻辑代码"></a>常见业务逻辑代码</h3><p>在改善之前我们的业务逻辑中残渣着这样的业务逻辑，我以“IM 发送消息”这个业务的 Mybatis 简单示例（真实情况可能更复杂），</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(String content, Long sessionID, Long senderID, Long reciverID)</span> &#123;<br>    <span class="hljs-comment">// 调用第三方内容安全对发送内容进行检查</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSafe</span> <span class="hljs-operator">=</span> contentChecker.check(content, Sence.CHAT);<br><br>    <span class="hljs-comment">// 检查用户是否存在</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectByID(senderID);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应用户不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否存在</span><br>    <span class="hljs-type">ChatSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> chatSessionMapper.selectByID(sessionID);<br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应会话不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否被关闭（封禁或对方拉黑）</span><br>    <span class="hljs-keyword">if</span> (session.isClosed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;检查是否被对方封禁&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新 session 未读计数</span><br>    <span class="hljs-type">SessionMeta</span> <span class="hljs-variable">sessionMeta</span> <span class="hljs-operator">=</span> sessionMetaMapper.selectByID(session.getID());<br>    sessionMeta.setUnreadCount(sessionMeta.getUnreadCount());<br>    <span class="hljs-keyword">if</span> (!sessionMetaMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 消息存库</span><br>    <span class="hljs-type">SessionMsg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionMsg</span>();<br>    msg.setID(idGenerator.get());<br>    msg.setSessionID(sessionID);<br>    msg.setSender(senderID);<br>    msg.setReciver(reciverID);<br>    msg.setContent(content);<br>    <span class="hljs-keyword">if</span> (!sessionMsgMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 投递 Kafka，让消费者推送 WebSocket</span><br>    <span class="hljs-type">KafkaMsg</span> <span class="hljs-variable">kafkaMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaMsg</span>();<br>    pushMsg.setTopic(TOPIC_PREFIX + userID);<br>    pushMsg.setMsg(content);<br>    kafkaMsgSender.push(kafkaMsg);<br><br>    <span class="hljs-comment">// 推送微信通知</span><br>    <span class="hljs-type">WechatSubMsg</span> <span class="hljs-variable">subMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatSubMsg</span>();<br>    subMsg.setUserID(reciverID);<br>    subMsg.setMsg(content);<br>    wechatApiProvider.pushMsg(subMsg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不仅仅是 Spring Boot-Mybatis 这样一种情况，事实上大多数 Web 开发都存在这样一种编码习惯</p></blockquote><p>相信不少同学的业务逻辑像我上面那样编写，那这样写有什么问题呢？对于小的项目或者小的业务功能时可能并无不妥，但是随着需求的变更，这里面可能会插入越来越多的业务逻辑，这样不断增长的“克苏鲁”将会造成以下问题。</p><h3 id="业务逻辑“消失”，认知成本升高"><a href="#业务逻辑“消失”，认知成本升高" class="headerlink" title="业务逻辑“消失”，认知成本升高"></a>业务逻辑“消失”，认知成本升高</h3><p>正如你所看见的，你不仔细阅读我的分支条件、数据库操作、与Kafka或者推送系统的交互，你很难明白我这一段代码的逻辑流程。我们都知道大多数业务逻辑都是存在一个业务流程的，但是当我们落实到编码的时候，业务逻辑被掩盖了。其他同学想要通过阅读我们的代码来搞懂我们的业务逻辑变得不那么容易，也就是“认知成本”变得很高。</p><h3 id="技术复杂度✖️业务复杂度"><a href="#技术复杂度✖️业务复杂度" class="headerlink" title="技术复杂度✖️业务复杂度"></a>技术复杂度✖️业务复杂度</h3><p>在当前后端的发展形势，我们的代码不仅要处理业务需求，还要处理如 MyBatis 等开发框架，Kafka等中间件，微服务架构等架构带来的技术复杂性。两个复杂性会导致我们的后端可维护性随着需求的变更快速下降。同时还会给项目带来技术风险，假如 MyBatis 框架出现了重大漏洞，要将 MyBatis 换为 Spring Data JDBC，那么我们的业务逻辑代码也需要变更，造成我们的技术变更成本高昂，无法快速应对技术风险！</p><h2 id="结构化分解与组合方法模式"><a href="#结构化分解与组合方法模式" class="headerlink" title="结构化分解与组合方法模式"></a>结构化分解与组合方法模式</h2><p>正如我们在面向过程语言中</p><h2 id="反转-Domain-和-Infrastructure-的依赖关系"><a href="#反转-Domain-和-Infrastructure-的依赖关系" class="headerlink" title="反转 Domain 和 Infrastructure 的依赖关系"></a>反转 Domain 和 Infrastructure 的依赖关系</h2><h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><p>大多数应用架构会选择这样的分层，</p><ul><li>domain</li><li>infrastructure</li></ul><p>大多数应用架构采取的依赖关系如下所示，</p><p>Controller -&gt; Service -&gt; DAO</p><p>Facade -&gt; Application -&gt; Domain -&gt; Infrastructure</p><p>事实上这种依赖方向是存在问题，主要的问题在于领域对象层 Domain 依赖于基础设施层，会使我们的业务代码夹杂着访问基础设施的代码，无法将技术与业务复杂度分离。</p><h3 id="COLA-的做法"><a href="#COLA-的做法" class="headerlink" title="COLA 的做法"></a>COLA 的做法</h3><p>COLA 通过在 Domain 中引入一个 <strong>Gateway</strong> 的概念，</p><ul><li>domain<ul><li>gateway</li></ul></li><li>infrastructure<ul><li>gatewayImpl</li></ul></li></ul><p>对于上面的代码，我们使用 Gateway 来重构一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(String content, Long sessionID, Long senderID, Long reciverID)</span> &#123;<br>    <span class="hljs-comment">// 调用第三方内容安全对发送内容进行检查</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSafe</span> <span class="hljs-operator">=</span> contentChecker.check(content, Sence.CHAT);<br><br>    <span class="hljs-comment">// 检查用户是否存在</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectByID(senderID);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应用户不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否存在</span><br>    <span class="hljs-type">ChatSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> chatSessionMapper.selectByID(sessionID);<br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;对应会话不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查会话是否被关闭（封禁或对方拉黑）</span><br>    <span class="hljs-keyword">if</span> (session.isClosed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;检查是否被对方封禁&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新 session 未读计数</span><br>    <span class="hljs-type">SessionMeta</span> <span class="hljs-variable">sessionMeta</span> <span class="hljs-operator">=</span> sessionMetaMapper.selectByID(session.getID());<br>    sessionMeta.setUnreadCount(sessionMeta.getUnreadCount());<br>    <span class="hljs-keyword">if</span> (!sessionMetaMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 消息存库</span><br>    <span class="hljs-type">SessionMsg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionMsg</span>();<br>    msg.setID(idGenerator.get());<br>    msg.setSessionID(sessionID);<br>    msg.setSender(senderID);<br>    msg.setReciver(reciverID);<br>    msg.setContent(content);<br>    <span class="hljs-keyword">if</span> (!sessionMsgMapper.updateByID(sessionMeta)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-string">&quot;保存数据异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 投递 Kafka，让消费者推送 WebSocket</span><br>    <span class="hljs-type">KafkaMsg</span> <span class="hljs-variable">kafkaMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaMsg</span>();<br>    pushMsg.setTopic(TOPIC_PREFIX + userID);<br>    pushMsg.setMsg(content);<br>    kafkaMsgSender.push(kafkaMsg);<br><br>    <span class="hljs-comment">// 推送微信通知</span><br>    <span class="hljs-type">WechatSubMsg</span> <span class="hljs-variable">subMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatSubMsg</span>();<br>    subMsg.setUserID(reciverID);<br>    subMsg.setMsg(content);<br>    wechatApiProvider.pushMsg(subMsg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送消息成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将贫血模型过渡到充血模型"><a href="#将贫血模型过渡到充血模型" class="headerlink" title="将贫血模型过渡到充血模型"></a>将贫血模型过渡到充血模型</h2><h3 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h3><h3 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h3><h2 id="使用边界上下文"><a href="#使用边界上下文" class="headerlink" title="使用边界上下文"></a>使用边界上下文</h2><h2 id="改善示例"><a href="#改善示例" class="headerlink" title="改善示例"></a>改善示例</h2>]]></content>
    
    
    <categories>
      
      <category>代码与艺术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一起来学Go——CGO极简教程（上）</title>
    <link href="/2022/08/18/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Go%E2%80%94%E2%80%94CGO%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2022/08/18/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Go%E2%80%94%E2%80%94CGO%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文旨在让使用 Go 语言做开发的同学通过简单的几十分钟快速掌握 Cgo 的使用，本文将会跳过复杂的底层原理介绍及不常用的功能，如果读者在阅读中遇到什么问题，可以在评论区留言。</p><h2 id="放在前面的故事"><a href="#放在前面的故事" class="headerlink" title="放在前面的故事"></a>放在前面的故事</h2><h3 id="初见-C"><a href="#初见-C" class="headerlink" title="初见 C"></a>初见 C</h3><p>简单和我的朋友们介绍一下我与C&#x2F;C++的爱恨情仇。熟悉我的朋友知道，我是高三学习的 Java，对于我而言 Java 是我进入计算机世界的第一门语言。我是在大一学院开设的“C语言程序设计”这门课上学习到了C语言，那时候我写C语言有一股“OOP的味道”～。</p><p>有了 Java 的基础学习 C 会非常快，那时候我很乐于帮助大家解决程序设计中的各种问题，尤其是“空指针”问题。（如图所示）</p><p><img src="https://img-blog.csdnimg.cn/20210302235059216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t1a2Vvbw==,size_16,color_FFFFFF,t_70" alt="C语言指针【“空指针”传参问题】_Kukeoo的博客-CSDN博客_空指针传入函数"></p><p>那时候最让我有成就感的事情就是帮助同学们解决一个又一个 C 语言空指针问题，无论代码长短，无论代码写得怎么样，只要有空指针，我就能快速定位问题并给予解决建议。那段时间也是我非常快乐的时间。</p><h3 id="步入-Android"><a href="#步入-Android" class="headerlink" title="步入 Android"></a>步入 Android</h3><p>大一的时候，由于学 Android 的人比较少，所以当时我加入的项目组基本都有开发 Android App 的需求，于是我在里边写各种各样的 App。</p><p>那时候 Flutter Dart 或 Jetpack Compose 还没有现在那么热门（这里感慨一下客户端市场变化速度之快），当时 Android 开发的主要语言就是 Java。但是 Java 的垃圾回收特性无法满足一些需求场景，比如视频流推拉，视频流处理等。当时我在 Android 平台上遇到的两大问题如下，</p><ul><li>尝试用 Java 进行视频转码，帧率高的时候引发 OutOfMemory</li><li>视频流推拉 GC 过于紧张造成 App 卡顿，手机发热，偶尔遇到 OutOfMemory</li></ul><p>当时对于第一个问题，我最后的解决方案是通过编写 C&#x2F;C++ 动态链接库，以及通过 JNI 进行调用。</p><p>对于第二个问题，我直接使用了 bilibili 站开源的 ijkPlayer 解决了，其中用到了开源的动态链接库，给你们看看我当时写的用来控制小车的 App 吧～</p><blockquote><p>ijkPlayer开源地址：<a href="https://github.com/bilibili/ijkplayer.git">https://github.com/bilibili/ijkplayer.git</a></p></blockquote><h3 id="CGO-之旅"><a href="#CGO-之旅" class="headerlink" title="CGO 之旅"></a>CGO 之旅</h3><p>大二开始我就逐渐回到云计算的阵营，主要往后端、区块链方面靠。于是 Android 成为了我手中的“玩具”，如果有人需要我就偶尔拿出来用一下。C&#x2F;C++ 的应用似乎在我的视野中慢慢淡出。</p><blockquote><p>为了不忘记 Android 这门“手艺”，我自己总结了一套敏捷开发方法论，之后抽空写一篇文章会分享大家</p></blockquote><p>最近遇到一些需求，要用 C&#x2F;C++ 来封装一些 Go 的代码，实现加速和技术封装。不仅让我发现 Cgo 这个非常高效的特性，也让我重新拾回了遗落的点滴～，那么废话不说了，开始我们的 CGo 之旅吧！</p><h2 id="CGO-简介"><a href="#CGO-简介" class="headerlink" title="CGO 简介"></a>CGO 简介</h2><p>Cgo 是 Go 语言自带的工具，来支持 C 语言的函数调用。Cgo 的主要目的是兼容 C&#x2F;C++ 庞大的软件资产。相较于其他语言的 C 本地调用功能，譬如 Java 的 JNI，Python 的 ctypes，CGO 具备简单易用的特性。</p><h2 id="Hello-CGO"><a href="#Hello-CGO" class="headerlink" title="Hello CGO"></a>Hello CGO</h2><p>废话不多说，直接上代码，看一个最简单的 Go 调用 C 的 <code>printf</code> 函数，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void callPrintf()&#123;</span><br><span class="hljs-comment">   printf(&quot;%d&quot;, 666);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   C.callPrintf()<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以试试看，运行结果如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wiki">666<br></code></pre></td></tr></table></figure><p>这就是一个最简单的 CGO 示例了，有几个地方需要介绍一下。</p><h3 id="1-import-“C”"><a href="#1-import-“C”" class="headerlink" title="1. import “C”"></a>1. import “C”</h3><p>这是 CGO 的基础语法，是打开跨语言大门的钥匙，任何 Go 与 C 之间的调用、参数转换等等，都需要通过这个导入这个虚拟的包 “C”。关于 import “C” 有以下几点说明，</p><ul><li><p>import “C” 需要独立一行，不能使用 Go 的批量导入语句</p></li><li><p>import “C” 上方的注释（无论单行、多行），会被当作 C 语言的代码</p><blockquote><p>import “C” 和代码不能有空行</p></blockquote></li><li><p>任何与 C 语言的交互都需要通过导入的虚拟的包 “C”</p></li></ul><p>在上面的示例中，我们在 import “C” 上方导入了著名的 stdio.h 包，然后编写了一个打印 666 的 <code>callPrintf()</code> 函数。除了使用 “C” 和我们自定义的 C 函数交互之外，我们还可以用它和库函数交互，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//#include &quot;call.c&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   C.callPrintf()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2. 类型转换"></a>2. 类型转换</h3><h4 id="整数类型转换"><a href="#整数类型转换" class="headerlink" title="整数类型转换"></a>整数类型转换</h4><p>如果我们希望传参给 C 函数，也需要通过“万能”的 “C”，看如下示例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void add(int a, int b)&#123;</span><br><span class="hljs-comment"> printf(&quot;%d&quot;, a + b);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br>import <span class="hljs-string">&quot;C&quot;</span><br>func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 C.int 我们成功将 Go 数值转化为 C 语言 int 类型的参数。如果我们希望从 C 函数接收返回值，可以参考如下示例，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">int add(int a, int b)&#123;</span><br><span class="hljs-comment"> return a + b;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>res = (<span class="hljs-type">int</span>)(C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>)))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果从 C 函数接收返回参数，有几种方法，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种方式，无需强制类型转换，但是如果下游需要使用该变量，可能还是需要强制类型转换</span><br>res := C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>))<br><span class="hljs-comment">// 第二种方式，直接强制类型转换，具体转换规则看下文</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>res = (<span class="hljs-type">int</span>)(C.add(C.<span class="hljs-type">int</span>(<span class="hljs-number">2</span>), C.<span class="hljs-type">int</span>(<span class="hljs-number">3</span>)))<br></code></pre></td></tr></table></figure><blockquote><p>大多数情况下，如果缺少强制转换，将会如下的错误，</p><p>cannot use (Cfunc_add)(Ctype_int(2), _Ctype_int(3)) (value of type _Ctype_int) as type int in assignment</p></blockquote><p>至此，你已经完成了 CGO 的 Hello World 了！但是我相信你肯定还有一堆疑问，请看下文我为你慢慢介绍。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>本节，我们着重介绍 CGO 的类型转换，解决了类型转换问题，事实上就将 CGO 中 80% 以上交互问题。</p><h3 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h3><p>下面讲解第一类比较特殊的转换，字符串的转换了，下面我们以“将传入的字符串转换为大写“为例编写了一个 CGo 程序，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">char* toUpperCase(char* str, int len)&#123;</span><br><span class="hljs-comment">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">        if(str[i] &lt;= 122 &amp;&amp; str[i] &gt;= 97)&#123;</span><br><span class="hljs-comment">            // 大写转小写</span><br><span class="hljs-comment">            str[i] -= 32;</span><br><span class="hljs-comment">        &#125;else if(str[i] &lt;= 90 &amp;&amp; str[i] &gt;= 65)&#123;</span><br><span class="hljs-comment">            // 小写不处理</span><br><span class="hljs-comment">        &#125;else&#123;</span><br><span class="hljs-comment">            // 非字母？</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return str;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;Hello World&quot;</span><br>  <span class="hljs-comment">// 转为 C “字符串”</span><br>strC := C.CString(str)<br>  <span class="hljs-comment">// 将返回值转为 GoString</span><br>res := (C.GoString)(C.toUpperCase(strC, C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(str))))<br>fmt.Println(res)<br><span class="hljs-comment">// 记得释放内存 CString 的内存，至于为什么我们之后详解</span><br>C.free(unsafe.Pointer(strC))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们演示了如何<strong>传入字符串参数</strong>和如何<strong>接收字符串返回值</strong>，主要指出两处操作</p><ul><li>通过 C.CString 将 Go string 转换为 C char* 指针，连同长度传入 C 函数</li><li>将 C 函数的返回值强制转换为 Go string</li></ul><p>当然你也可以选择通过 strlen 在 C 语言内获取字符串长度，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;stdlib.h&gt;<br>#include &lt;<span class="hljs-type">string</span>.h&gt;<br>char* toUpperCase(char* str)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = strlen(str);<br>    ... <span class="hljs-comment">// 省略重复代码</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组与切片传递"><a href="#数组与切片传递" class="headerlink" title="数组与切片传递"></a>数组与切片传递</h3><p>切片和数组的传递本质上其实都是<strong>从 Go 传递数组到 C</strong>，看下面的示例就懂啦，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">int sum(int* arr, int len)&#123;</span><br><span class="hljs-comment">int res = 0;</span><br><span class="hljs-comment">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">res += arr[i];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">return res;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []C.<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>res := (<span class="hljs-type">uint</span>)(C.sum(&amp;arr[<span class="hljs-number">0</span>], C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(arr))))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于数组来说我们，我们的传递也比较简单，本质上其实传递数组的地址<code>&amp;arr[0]</code>。</p><blockquote><p>习惯写 C 语言的同学可能会直接传递 arr，加上 IDE 普遍没有 CGO 的补全功能，注意区分 Go 和 C 哈。</p></blockquote><p>那么数组的返回值要怎么接收呢？我并不推荐返回数组给 Go 语言，具体原因请看后续 CGO 的其他文章。</p><h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><p>众所周知 Go 和 C 语言都有结构体类型，那么是不是意味着我们 CGO 的转换也会如此简单呢？</p><p>很遗憾，两者的转换不仅复杂，而且还会有诸多限制，如果要传入结构体类型给 C 函数，那么需要在 Go 语言中使用 C 函数定义的结构体类型，如下示例，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct Data&#123;</span><br><span class="hljs-comment">int data1;</span><br><span class="hljs-comment">float data2;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">float sumData(struct Data d)&#123;</span><br><span class="hljs-comment">return d.data1 + d.data2;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data C.struct_Data<br>  <span class="hljs-comment">// 成员赋值</span><br>  data.data1 = <span class="hljs-number">3</span> <span class="hljs-comment">// C.int(3)</span><br>  data.data2 = <span class="hljs-number">0.14</span> <span class="hljs-comment">// C.float(0.14)</span><br>res := (<span class="hljs-type">float32</span>)(C.sumData(data))<br>fmt.Println(res)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们首先要在 C 语言中预定义该结构体，并在 Go 中声明使用它，各种变量之间的类型转换也需要我们去处理。好在这里 Go 做了处理，不需要我们使用 C.XXX 显式转换。</p><h2 id="令人流泪的坑"><a href="#令人流泪的坑" class="headerlink" title="令人流泪的坑"></a>令人流泪的坑</h2><h3 id="传入的字符串如果中英混合要怎么处理"><a href="#传入的字符串如果中英混合要怎么处理" class="headerlink" title="传入的字符串如果中英混合要怎么处理"></a>传入的字符串如果中英混合要怎么处理</h3><p>众所周知，在 C&#x2F;C++ 中处理中文字符是一件头疼的事情，除了要识别目标主机大小端，还需要处理操作系统的差异。所以我的建议是，非必要不要跨语言传递中英文混合字符串。</p><p>通常来说传递中文字符串是为了获得每个中文字符的 Unicode 并进行一些处理，这里我推荐下面的做法，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">void printSlice(int* arr, int len)&#123;</span><br><span class="hljs-comment">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="hljs-comment">printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;哈罗沃德&quot;</span><br>runes := []<span class="hljs-type">rune</span>(s)<br>sUCode := <span class="hljs-built_in">make</span>([]C.<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(runes))<br><span class="hljs-comment">// 进行转换</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(runes); i++ &#123;<br>sUCode[i] = C.<span class="hljs-type">int</span>(runes[i])<br>&#125;<br>C.printSlice(&amp;sUCode[<span class="hljs-number">0</span>], C.<span class="hljs-type">int</span>(<span class="hljs-built_in">len</span>(sUCode)))<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是将处理中文字符的问题交给 Go 语言的 runes。</p><blockquote><p>如果后续本人有更加好的 CGO 处理方式，将会另开一篇文章</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal 源码完全解析</title>
    <link href="/2022/05/27/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20ThreadLocal%20%E6%BA%90%E7%A0%81%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/05/27/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20ThreadLocal%20%E6%BA%90%E7%A0%81%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪高超的技术餐</p></blockquote><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><h3 id="1-官方文档解读"><a href="#1-官方文档解读" class="headerlink" title="1. 官方文档解读"></a>1. 官方文档解读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wiki">This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br></code></pre></td></tr></table></figure><p>意思非常简单，<code>ThreadLocal</code> 提供了一个线程本地变量的实现，这些本地变量在初始化的时候会进行拷贝，线程可以通过 <code>get</code> 和 <code>set</code> 方法与其进行交互。</p><h3 id="2-官方示例"><a href="#2-官方示例" class="headerlink" title="2. 官方示例"></a>2. 官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadId</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 这里定义了一个 static 的 threadId </span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 因为 ++ 并不是一个线程安全的操作，所以这里使用了 atomic 的 CAS</span><br>      <span class="hljs-keyword">return</span> nextId.getAndIncrement();<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> threadId.get();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官方提供了一个如上所示的示例，<code>ThreadId</code> 类中有一个 <strong>static</strong> 的 <code>ThreadLocal</code> 类型变量，并且重写了其中的 <code>initialValue()</code> 方法，该方法会返回 nextId 的值并且加一。</p><p>由于官方没有提供使用示例，为了更加轻松地理解该类是如何使用 <code>ThreadLocal</code> 工作的，这里作者提供一个如下的使用示例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, 我的第一次输出为：&quot;</span> + ThreadId.get());<br><br>        <span class="hljs-comment">// 休眠一段时间，来混淆调度</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;我是&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, 我的第二次输出为：&quot;</span> + ThreadId.get());<br>      &#125;<br>    &#125;, <span class="hljs-string">&quot;thread-&quot;</span> + i);<br>    thread.start();<br>  &#125;<br><br>  <span class="hljs-comment">// 主线程等待子线程都执行完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读者可以拷贝上面的代码来尝试运行，多次运行输出有所不同，下面是我的其中一次输出，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">我是thread-1, 我的第一次输出为：1<br>我是thread-3, 我的第一次输出为：3<br>我是thread-4, 我的第一次输出为：4<br>我是thread-0, 我的第一次输出为：0<br>我是thread-5, 我的第一次输出为：5<br>我是thread-2, 我的第一次输出为：2<br>// 名为“thread-6”的线程，第一次输出为“6”<br>我是thread-6, 我的第一次输出为：6<br>我是thread-7, 我的第一次输出为：7<br>我是thread-8, 我的第一次输出为：8<br>我是thread-9, 我的第一次输出为：9<br>我是thread-3, 我的第二次输出为：3<br>我是thread-5, 我的第二次输出为：5<br>我是thread-9, 我的第二次输出为：9<br>我是thread-1, 我的第二次输出为：1<br>// 名为“thread-6”的线程，第二次输出为“6”<br>我是thread-6, 我的第二次输出为：6<br>我是thread-4, 我的第二次输出为：4<br>我是thread-8, 我的第二次输出为：8<br>我是thread-7, 我的第二次输出为：7<br>我是thread-0, 我的第二次输出为：0<br>我是thread-2, 我的第二次输出为：2<br></code></pre></td></tr></table></figure><p>我们从输出中很容易看出对于每个线程而言，<strong>其读取的 threadId 的值都是相同的</strong>，这是非常奇妙的地方。</p><p>我们知道，如果把 threadId 的类型换回普通的 <code>Integer</code> 后直接共享，得到的结果可能是每个线程多次读取的值都不相同。</p><p>那 <code>ThreadLocal</code> 是如何帮助我们实现这一点的呢？请看后文分解～</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="1-ThreadLocal-管理的变量存储在哪？"><a href="#1-ThreadLocal-管理的变量存储在哪？" class="headerlink" title="1. ThreadLocal 管理的变量存储在哪？"></a>1. ThreadLocal 管理的变量存储在哪？</h3><p>我们分析一下 ThreadLocal 的 <code>get</code> 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>    ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法的执行步骤，</p><ol><li><p>调用 <code>getMap()</code> 获取 <code>ThreadLocalMap</code> 对象</p></li><li><p>判断 map 是否为空</p><p> 2.1 如果 map 非空则尝试从 map 中获取保存的值</p><p> 2.2 如果值非空则直接返回</p></li><li><p>如果 map 为空则执行 <code>setInitialValue</code> 方法并返回其值</p></li></ol><p>下面我们看看 <code>setInitialValue()</code> 干了什么事情，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    createMap(t, value);<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，该方法调用了 <code>initialValue()</code>，这个方法默认的返回值是 null。在官方示例中，我们重写了它，用于分配给不同的线程分配不同的值。</p><p>接下来的逻辑就是尝试获取 <code>ThreadLocalMap</code>，如果 map 不存在就先创建一个，然后保存 <code>initialValue()</code> 返回的值。</p><h3 id="2-ThreadLocalMap-解析"><a href="#2-ThreadLocalMap-解析" class="headerlink" title="2. ThreadLocalMap 解析"></a>2. ThreadLocalMap 解析</h3><p>从上面的推断中，我们可以知道 <code>ThreadLocal</code> 保存的值本质上是存储在 <code>ThreadLocalMap</code> 类中，**<code>ThreadLocal</code> 实际上是 Map 中的 key**。下面我们来着重分析这个类，下面我们贴上比较核心的一部分代码，也是我们即将分析的代码。</p><blockquote><p>补充精简版代码</p></blockquote><h4 id="如何存储-ThreadLocal-的每一项值——set"><a href="#如何存储-ThreadLocal-的每一项值——set" class="headerlink" title="如何存储 ThreadLocal 的每一项值——set()"></a>如何存储 ThreadLocal 的每一项值——<code>set()</code></h4><p>大多数情况下是我们只关注如何使用 <code>ThreadLocal</code>，那么我们就来分析与存储和获取相关的方法，先来看看 <code>set()</code> 做了哪些工作，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>  <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>  <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>  <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>  <span class="hljs-comment">// path would fail more often than not.</span><br><br>  Entry[] tab = table;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>       e != <span class="hljs-literal">null</span>;<br>       e = tab[i = nextIndex(i, len)]) &#123;<br>    <span class="hljs-keyword">if</span> (e.refersTo(key)) &#123;<br>      e.value = value;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (e.refersTo(<span class="hljs-literal">null</span>)) &#123;<br>      replaceStaleEntry(key, value, i);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>  <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希表的每项格式——Entry"><a href="#哈希表的每项格式——Entry" class="headerlink" title="哈希表的每项格式——Entry"></a>哈希表的每项格式——<code>Entry</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>  <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>  Object value;<br><br>  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>    <span class="hljs-built_in">super</span>(k);<br>    value = v;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，每个 <code>ThreadLocal</code> 的值被保存在每个 <code>Entry</code> 中，其中 key 为 <code>ThreadLocal</code>。</p><h4 id="ThreadLocalMap-是如何创建的——构造方法"><a href="#ThreadLocalMap-是如何创建的——构造方法" class="headerlink" title="ThreadLocalMap 是如何创建的——构造方法"></a>ThreadLocalMap 是如何创建的——构造方法</h4><p>ThreadLocalMap 有两个构造方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>  <span class="hljs-comment">// 计算哈希表的索引位置</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 创建相应的位置</span><br>  table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>  size = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 设置进行 rehash 的阈值</span><br>  setThreshold(INITIAL_CAPACITY);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>  Entry[] parentTable = parentMap.table;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>  setThreshold(len);<br>  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br><br>  <span class="hljs-keyword">for</span> (Entry e : parentTable) &#123;<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>      <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从父 map 中获取值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value); <span class="hljs-comment">//（1）</span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>        <span class="hljs-comment">// 重新计算每个 Entry 的新位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 遇到空的 Entry 就跳过</span><br>          h = nextIndex(h, len);<br>        table[h] = c;<br>        size++;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个构造方法是对构造一个哈希表并向其存入一个值。</p><p>第二个构造方法稍微复杂一些，看上去是将一个 <code>ThreadLocalMap</code> 拷贝到新的 <code>ThreadLocalMap</code>，但我们仔细去看（1）处的 <code>childValue()</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现是直接抛出异常，事实上这个方法交给了 <code>InheritableThreadLocal</code>，这个类是为了解决<strong>线程之间 ThreadLocal 的继承问题</strong>，这个问题我们以后再聊。</p><p>在阅读完本篇文章后，你只需要知道第二个构造方法在大多数场景下不是由你来调用的，它是用于父线程和子线程之间的 ThreadLocal 的继承。</p><h4 id="ThreadLocalMap-的哈希函数好像不太一样？"><a href="#ThreadLocalMap-的哈希函数好像不太一样？" class="headerlink" title="ThreadLocalMap 的哈希函数好像不太一样？"></a>ThreadLocalMap 的哈希函数好像不太一样？</h4><p>我们可以看到在 <code>ThreadLocal</code> 的代码中存在这样的计算方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而 threadLocalHashCode 的值来源如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt;&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>  <br>  <span class="hljs-comment">// nextHashCode 的增长步长</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看到哈希函数所使用的计算值不是 <code>Object</code> 的 <code>hashCode()</code>，而是用一个静态的 <code>AtomicInteger</code> 类型变量和一个固定的步长生成的，为什么要这样设计？</strong></p><p>我们看到 <code>Entry</code> 没有使用 <code>HashMap</code> 中的 <code>Node</code> 红黑树的设计，这是因为 <code>ThreadLocalMap</code> 在大多数场景下，需要保存的值的数量相对固定且离散，不需要专门为了解决哈希冲突而做冲突设计，节省了内存。</p><p><strong>那么为什么不使用 ThreadLocal 的 hashCode 来计算哈希值呢？</strong></p><p>这个问题也很好回答，既然 <code>ThreadLocalMap</code> 从设计之初就没有打算考虑哈希冲突，那自然要从源头上避免哈希冲突的产生，于是 <code>ThreadLocal</code> 选择了自己来生成 nextHashCode，而是通过静态原子变量来统一为每个 <code>ThreadLocal</code> 对象分配 nextHashCode。</p><p>然后为什么使用 0x61c88647 作为增长步长，我们可以做一个小实验来模拟 ThreadLocal 被多次创建的过程，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h2 id="为什么-Entry-要使用弱引用"><a href="#为什么-Entry-要使用弱引用" class="headerlink" title="为什么 Entry 要使用弱引用"></a>为什么 Entry 要使用弱引用</h2><h2 id="ThreadLocal-的应用"><a href="#ThreadLocal-的应用" class="headerlink" title="ThreadLocal 的应用"></a>ThreadLocal 的应用</h2><h3 id="Spring-Security-保存鉴权结果"><a href="#Spring-Security-保存鉴权结果" class="headerlink" title="Spring Security 保存鉴权结果"></a>Spring Security 保存鉴权结果</h3>]]></content>
    
    
    <categories>
      
      <category>爆肝源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分页查询优化</title>
    <link href="/2022/04/28/MySQL/MySQL%20%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <url>/2022/04/28/MySQL/MySQL%20%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="分页查询简介"><a href="#分页查询简介" class="headerlink" title="分页查询简介"></a>分页查询简介</h2><p>可以说，如果读者参与过网络应用的开发，分页查询一定是家常便饭了。比如电商商品列表，论坛帖子列表等等。而一般来说，分页查询其实包括以下两种。</p><ul><li>逻辑分页：在用户第一次访问时，将数据全部查出，添加到 Session 中，然后通过页码和页大小查出其中一部分返回给用户。缺点非常明显，如果数据量比较大的话，将耗费大量的内存；如果数据频繁更新，则内存中的数据容易过期，需要频繁更新。</li><li>物理分页：使用数据库自身的分页机制，每一次分页都会去查询数据库。</li></ul><p>本文只重点介绍物理分页及其优化方案。</p><p>常见的分页查询语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> [col1, col2 ...] <span class="hljs-keyword">from</span> [table_name] <span class="hljs-keyword">where</span> cond1 [<span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-keyword">or</span>] cond2 ... limit [<span class="hljs-keyword">offset</span>], [length];<br></code></pre></td></tr></table></figure><p>分页要关注只有两个参数，</p><ul><li><code>offset</code>（可选）：偏移量，指从表第一行开始，可以理解为页起始位。</li><li><code>length</code>：目标行数，可以理解为页大小。</li></ul><p>希望读者注意一点，分页不是指对表的所有行记录进行分页查询，而是<strong>对表中符合条件的所有行记录</strong>进行分页查询。</p><p>当然，如果没有条件或者表中行记录均符合条件的话，那就等价于对表中的所有行记录进行分页查询。</p><blockquote><p>为什么这一点很重要？因为如果认为分页查询的对象是指表中的所有行，那么在后续的阅读中可能会陷入一个问题，</p><p>“为什么 MySQL 不能像数组那样直接定位 offset 的位置，而是一直遍历直到找到符合条件的行记录呢？”</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>假设我们有这样一个场景，某电商系统使用了如下所示的表来存储商品信息，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> good_info<br>(<br>    good_id     <span class="hljs-type">bigint</span>        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">primary</span> key,<br>    good_name   <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    good_desc   <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    state       tinyint       <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    create_time <span class="hljs-type">int</span>     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    sell_count  <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">create</span> index good_info_create_time_index<br>    <span class="hljs-keyword">on</span> good_info (create_time <span class="hljs-keyword">desc</span>);<br></code></pre></td></tr></table></figure><p>各个字段的意义如下，</p><ul><li>good_id：商品唯一 id</li><li>good_name：商品名称</li><li>good_desc：商品描述</li><li>state：商品状态，这里假定存在两种状态，正在出售和库存不足</li><li>create_time：发布时间，为了方便后续的测试数据生成，我们使用整数来代替 timestamp 或 datetime</li><li>sell_count：销售量</li></ul><p>我们接下来使用<code>存储过程</code>来给它添加一点点数据，</p><p><strong>定义随机字符串生成函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">int</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> chars_str <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;<br>  <span class="hljs-keyword">declare</span> return_str <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  while i <span class="hljs-operator">&lt;</span> n do<br>      <span class="hljs-keyword">set</span> return_str<span class="hljs-operator">=</span>concat(return_str,<span class="hljs-built_in">substring</span>(chars_str,<span class="hljs-built_in">floor</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>rand()<span class="hljs-operator">*</span><span class="hljs-number">62</span>),<span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">set</span> i<span class="hljs-operator">=</span> i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span> while;<br>  <span class="hljs-keyword">return</span> return_str;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>定义数据生成存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span><br>    definer <span class="hljs-operator">=</span> lwj<span class="hljs-variable">@localhost</span> <span class="hljs-keyword">procedure</span> gen_data(<span class="hljs-keyword">IN</span> n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<br>    WHILE (i <span class="hljs-operator">&lt;=</span> n ) DO<br>      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> good_info (good_id, good_name, good_desc, state, create_time) <span class="hljs-keyword">VALUEs</span> (i, rand_string(<span class="hljs-number">20</span>), rand_string(<span class="hljs-number">50</span>), <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">2</span>) , <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">1000000</span>));<br>            <span class="hljs-keyword">set</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><strong>执行存储过程</strong></p><p>这里作者选择随机生成 1 千万行数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> gen_data(<span class="hljs-number">10000000</span>);<br></code></pre></td></tr></table></figure><p>执行了 28 m 57 s，终于成功生成了 1 千万条测试数据，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204281221643.png"></p><blockquote><p>读者可能会疑惑，为什么不选择其他外部的测试数据生成方法而选择存储过程。的确，外部生成方式更加灵活，但是性能远比存储过程差，存储过程自创建后就编译并存储在MySQL中。</p></blockquote><h2 id="分页查询的问题"><a href="#分页查询的问题" class="headerlink" title="分页查询的问题"></a>分页查询的问题</h2><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>假如我们有以下的这个分页查询语句，我们调整 offset 和 length，统计查询的平均耗时，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit ?, ?;<br></code></pre></td></tr></table></figure><p>如下为测试结果，</p><table><thead><tr><th>offset</th><th>length</th><th>查询耗时（ms）</th></tr></thead><tbody><tr><td>100</td><td>20</td><td>25</td></tr><tr><td>1000</td><td>20</td><td>48</td></tr><tr><td>10000</td><td>20</td><td>809</td></tr><tr><td>100000</td><td>20</td><td>13762</td></tr><tr><td>1000000</td><td>20</td><td>18966</td></tr></tbody></table><p>我们来 <code>explain</code> 一下各个语句，对于 offset 为 10000 及以下的情况如下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="center">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">index</td><td align="left">NULL</td><td align="left">good_info_create_time_index</td><td align="left">4</td><td align="center">NULL</td><td align="left">120</td><td align="left">100</td><td align="left">NULL</td></tr></tbody></table><p>对于 offset 为 100000 及以上的情况如下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">ALL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">9933232</td><td align="left">100</td><td align="left">Using filesort</td></tr></tbody></table><p>可以看到 <code>offset</code> 为 10000 及左右情况下，优化器还是会选择走索引的，但是像 100000 及以上的情况下，优化器会选择全表，这是为什么呢？为了揭晓这个答案我们可以使用 <code>hint</code>（优化器提示）来强制走索引，看看是怎么一回事儿。</p><p>对于 <code>offset</code> 为 100000 的情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info force index(good_info_create_time_index) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>统计结果耗时为 7922ms，这时候是比优化器选择的全表要快的。</p><p>对于 <code>offset</code> 为 1000000 的情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info force index(good_info_create_time_index) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>统计结果耗时为 1m 6s 4ms！</strong></p><p>也就是说，在 <code>offset</code> 比较大的时候优化器会选择全表而不是查询，因为<strong>全表可能会比走索引更加快</strong>。</p><blockquote><p>读者必须知道优化器并不总是精确的，它是一个综合了各项指标的经验机器，所以才会出现 100000 的情况下不走索引。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分页查询的问题本质上其实是 <code>offset</code> 的问题，首先我们要知道分页查询的过程中，SQL 的执行流程。</p><p>SQL 走索引的执行流程如图所示，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204272255961.png" style="zoom:50%;" /><p>在分页查询中，对于每一行来说都要经过以下的过程，</p><ol><li>通过二级索引查找找到对应的行的主键</li><li>通过主键找到对应的行记录</li><li>通过行记录判断该行是否符合 where 条件</li></ol><p>也就是说，默认的分页查询中会产生非常多次数的回表查询，<code>offset</code> 为 10000，<code>length</code> 为 20 的情况下，SQL 走索引至少要回表查询 10020 次。</p><p>在表中的数据量日渐庞大的情况下，回表查询的代价也是不断上升的，<strong>最终会导致分页走索引的代价比全表查询要高</strong>，所以优化器才会在 <code>offset</code> 较大的情况下选择走全表而不是索引。</p><h2 id="优化分页查询的思路"><a href="#优化分页查询的思路" class="headerlink" title="优化分页查询的思路"></a>优化分页查询的思路</h2><h3 id="id-范围查询"><a href="#id-范围查询" class="headerlink" title="id 范围查询"></a>id 范围查询</h3><p>理想状态下，如果读者想要优化的表具备以下特点，则可以使用 <strong>id 范围查询</strong>来直接定位到需要的数据页范围，</p><ul><li>主键是严格自增的</li><li>表中的数据一经 insert，就不会 delete 的</li><li>主键列不会被修改</li></ul><p>优化前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>耗时 13762ms</p><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-keyword">between</span> <span class="hljs-number">1000000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1000020</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>耗时 10ms，简直是质的飞跃啊！explain 一下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">range</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">NULL</td><td align="left">21</td><td align="left">100</td><td align="left">Using where; Using filesort</td></tr></tbody></table><p>进一步，因为 id 总是自增的，所以后发布的商品其 id 总是更加大一些，所以如果我们可以根据 good_id 来进行排序，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-keyword">between</span> <span class="hljs-number">1000000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1000020</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> good_id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>explain 一下就发现 Extra 中的 <code>filesort</code> 变成为了 <code>Backward index scan</code>。</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">range</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">NULL</td><td align="left">21</td><td align="left">100</td><td align="left">Using where; Backward index scan</td></tr></tbody></table><p>这两者效率有什么不同？简单来说，filesort 需要做一次额外的排序工作，而 Backward index scan 利用了<strong>主键列索引双向链表</strong>直接获得排序后的结果，无需额外的排序工作。</p><blockquote><p>InnoDB 主键列 B+ 树叶子结点按照主键的大小升序排序，而我们的查询要求降序排序，于是查询会使用叶子结点双向链表倒序扫描来获取结果。</p></blockquote><h3 id="标签法"><a href="#标签法" class="headerlink" title="标签法"></a>标签法</h3><p><strong>id 范围查询</strong>的条件是非常理想的，如果服务有分布式的需求的话，可能会将 id 变更为分布式一致性 id，比如雪花 id 等。在这种情况下主键就不是严格自增的了，也就无法使用上述的 <strong>id 范围查询</strong>来优化。本节介绍的标签法则也是一种比较好的方法，能克服上述问题。</p><p>标签法利用历史分页记录来实现，结合了实际的应用场景，我们想象一下在社交论坛列表或者电商商品列表中，用户的行为总是向下滑。换言之，这些场景下的分页查询中，用户请求总是请求”下一页“。</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/202204281514618.png" style="zoom:50%;" /><p>于是，我们可以用另外的表记录用户的“上一页”的位置，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_page<br>(<br>    user_id     <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">primary</span> key,<br>    next_offset <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><ul><li>user_id：用户的业务 id</li><li>next_offset：该用户下一次分页查询的起始位置</li></ul><p>然后在分页查询的时候使用“历史”表，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> good_info <span class="hljs-keyword">where</span> good_id <span class="hljs-operator">&gt;=</span> (<span class="hljs-keyword">select</span> next_offset <span class="hljs-keyword">from</span> user_page <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> ?) limit <span class="hljs-number">20</span>;<br><span class="hljs-keyword">update</span> user_page <span class="hljs-keyword">set</span> next_offset <span class="hljs-operator">=</span> next_offset <span class="hljs-operator">+</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>这里通过子查询得到了下一次分页 good_id 的起始位置，limit 参数只用于指定页大小。每次分页查询结束后，更新下一次用户的起始位置。</p><p>耗时 29 + 16 ms。也是一种非常不错的方案。</p><h3 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h3><p>如果你的表存在非尾部插入、删除中间行和二级索引树叶子节点值经常变动的情况，那么上面的两种办法都是不行的，比如对商品销售量降序分页查询。</p><p>这时候我们就可以采用使用场景最广的分页查询优化方案——延迟关联。</p><p>所谓延迟关联，其实就是为了避免分页的每一行都进行回表查询，而是通过一种办法一次性找到需要行后再进行回表查询。下面直接给出延迟关联的查询语句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> good_info <span class="hljs-keyword">as</span> g1 <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> good_id <span class="hljs-keyword">FROM</span> good_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> LIMIT <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>) <span class="hljs-keyword">as</span> g2 <span class="hljs-keyword">on</span> g1.good_id <span class="hljs-operator">=</span> g2.good_id<br></code></pre></td></tr></table></figure><p>耗时：135 ms</p><p>explain 一下，</p><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left">&lt;derived2&gt;</td><td align="left">NULL</td><td align="left">ALL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">NULL</td><td align="left">1000020</td><td align="left">100</td><td align="left">NULL</td></tr><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left">g1</td><td align="left">NULL</td><td align="left">eq_ref</td><td align="left">PRIMARY</td><td align="left">PRIMARY</td><td align="left">8</td><td align="left">g2.good_id</td><td align="left">1</td><td align="left">100</td><td align="left">NULL</td></tr><tr><td align="left">2</td><td align="left">DERIVED</td><td align="left">good_info</td><td align="left">NULL</td><td align="left">index</td><td align="left">NULL</td><td align="left">good_info_create_time_index</td><td align="left">4</td><td align="left">NULL</td><td align="left">1000020</td><td align="left">100</td><td align="left">Using index</td></tr></tbody></table><p>我们可以看到，自查询中使用了<strong>覆盖索引</strong>来获取符合条件的 good_id，再通过 good_id 去查询主键树来得到结果。最终回表查询次数缩减为页大小，也就是 20 行。</p><blockquote><p>如果一个索引包含（覆盖）我们所需要查询的所有字段值，我们就称之为<strong>覆盖索引</strong>。比如 create_time 的索引树叶子结点存在我们需要的主键的值，那么子查询就不需要回表查询。</p></blockquote><p>其实还有一种<strong>子查询优化</strong>的方法，和延迟关联的思路其实是一样的，都是减少回表查询次数，这里不再赘述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分页查询的优化是非常重要的， 对于线上系统来说，差的分页查询将会成为系统的瓶颈。而本文只从 MySQL 层面谈及了分页查询的多种优化方法，还有一类通过外部缓存实现的分页查询优化，我们以后有机会再说。如果你觉得我写得还不错，可以为点赞和关注～～</p>]]></content>
    
    
    <categories>
      
      <category>MySQL优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EMQX 的集群搭建</title>
    <link href="/2022/04/06/EMQX/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EMQX%20%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/04/06/EMQX/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EMQX%20%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="上文回顾"><a href="#上文回顾" class="headerlink" title="上文回顾"></a>上文回顾</h2><p>在上文，我们介绍了 EMQX 的快速上手体验，本文将会延续上文的基础继续介绍 EMQX 的集群搭建。</p><h2 id="EMQX-集群配置"><a href="#EMQX-集群配置" class="headerlink" title="EMQX 集群配置"></a>EMQX 集群配置</h2><p>按照之前的基础，我们已经为 192.168.100.100 搭建了一个 EMQX，现在我们可以利用 Linux 集群分发机制实现在 192.168.100.101 和 192.168.100.102 上快速部署 EMQX。</p><p>如果不清楚如何使用集群分发机制，可以参考下面的文章，</p><p>下面我们只需要使用之前的集群分发脚本，将 emqx 的环境配置与安装目录同步到集群 centos 中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">syncall /etc/profile.d/my_emqx.sh<br>syncall /opt/module/emqx/<br></code></pre></td></tr></table></figure><p>这样对于其他的主机来说，emqx 就已经安装好了，接下来我们就进入集群设置环境。</p><blockquote><p>可能需要让环境变量生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure></blockquote><h2 id="static-集群"><a href="#static-集群" class="headerlink" title="static 集群"></a>static 集群</h2><p>static 集群是通过预先存储在各节点的 EMQX 节点的节点列表来实现集群的发现，配置方法较为简单，我们到 192.168.100.100 的节点配置文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件在安装目录下的 etc/emqx.conf</span><br>vim /opt/module/emqx/etc/emqx.conf<br></code></pre></td></tr></table></figure><p>修改文件内容如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改集群模式为 static</span><br>cluster.discovery = static<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置节点发现列表</span><br>cluster.static.seeds = emqx@192.168.100.100,emqx@192.168.100.101,emqx@192.168.100.102<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置节点名称，请注意，节点标识必须和上面节点发现列表中的一致，否则将无法实现集群节点发现</span><br>node.name = emqx@192.168.100.100<br></code></pre></td></tr></table></figure><p>保存后，我们就已经成功修改了 192.168.100.100 的节点集群配置，利用集群分发将配置拷贝到其他节点后，我们只需要修改 192.168.100.101 和 192.168.100.102 配置文件中的节点名称即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">101</span><br>node.name = emqx@192.168.100.101<br><span class="hljs-meta prompt_"># </span><span class="language-bash">102</span><br>node.name = emqx@192.168.100.102<br></code></pre></td></tr></table></figure><p>现在让我们启动集群中的每个节点，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx restart<br></code></pre></td></tr></table></figure><p>进入控制台，看看效果如何，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405185135385.png" alt="image-20220405185135385"></p><p>可以看到在不同的节点上，监控界面显示的节点数如图所示，说明集群已经启动。</p><h2 id="验证集群发布与订阅"><a href="#验证集群发布与订阅" class="headerlink" title="验证集群发布与订阅"></a>验证集群发布与订阅</h2><p>我们如果要进一步验证集群功能是否正常，其实也非常简单，我们来测试跨节点的发布订阅功能，</p><p>现在让我们使用 MQTTX 工具对 192.168.100.100 节点进行订阅，订阅的主题是 testtopic，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405190541047.png" alt="image-20220405190541047"></p><p>现在我们使用另外一个连接，连接到 192.168.100.101 节点，并向 testtopic 发送消息。</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405191115474.png" alt="image-20220405191115474"></p><p>可以看到另外一个连接收到了消息，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405191145030.png" alt="image-20220405191145030"></p><h2 id="配置-Nginx-网关"><a href="#配置-Nginx-网关" class="headerlink" title="配置 Nginx 网关"></a>配置 Nginx 网关</h2><p>集群搭建完后，我们的工作并没有结束，我们需要一个提供一个外部的统一的入口。集群通常是部署在内网的，不具备外网 IP，即使外网 IP 可知，让客户端一次性保存所有节点的 IP 也是不现实的，因为节点可能动态横向扩展并。除此之外，我们需要平衡客户端的访问流量，也就是需要做负载均衡。</p><p>本节我们选择用 Nginx 来作为 EMQX 集群的网关，最终搭建的效果如下所示，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220405205839.png"></p><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>方便起见我们直接这样安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y nginx<br></code></pre></td></tr></table></figure><blockquote><p>读者如果出现 No package nginx available，说明需要配置 epel 源，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install epel-release <br></code></pre></td></tr></table></figure></blockquote><p>启动 nginx，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure><p>验证 nginx 是否启动成功，访问 <a href="http://192.168.100.100,如果显示以下页面,或者/">http://192.168.100.100，如果显示以下页面，或者</a> nginx 首页，则说明 nginx 正常运行，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405212714044.png" alt="image-20220405212714044"></p><h3 id="配置-nginx-负载均衡"><a href="#配置-nginx-负载均衡" class="headerlink" title="配置 nginx 负载均衡"></a>配置 nginx 负载均衡</h3><p>如果你是通过 yum 安装 nginx，则配置文件位置为 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf，因为对 emqx 进行反向代理本质上是对 websocket 进行反向代理，我们还需要安装一个插件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install nginx-mod-stream -y<br></code></pre></td></tr></table></figure><h4 id="SSL-证书的-nginx-负载均衡配置（推荐）"><a href="#SSL-证书的-nginx-负载均衡配置（推荐）" class="headerlink" title="SSL 证书的 nginx 负载均衡配置（推荐）"></a>SSL 证书的 nginx 负载均衡配置（推荐）</h4><p>准备 SSL 证书，如果你只是想要进行尝试，可以申请阿里云免费 SSL 证书，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406141533852.png" alt="image-20220406141533852"></p><p>作者将证书上传到了 &#x2F;etc&#x2F;nginx&#x2F;cert 目录内。</p><p>于是在 nginx 配置文件中，我们添加以下配置，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">stream</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 轮询负载均衡配置</span><br>  <span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 max_fails=2 fail_timeout=30s;</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">      # 监听 8883 端口 SSL</span><br>      <span class="hljs-attr">listen</span> <span class="hljs-string">8883 ssl;</span><br><span class="hljs-comment">      # 反向代理到 emqx_cluster</span><br>      <span class="hljs-attr">proxy_pass</span> <span class="hljs-string">emqx_cluster;</span><br>      <span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br>      <span class="hljs-attr">ssl_handshake_timeout</span> <span class="hljs-string">15s;</span><br><span class="hljs-comment">      # 证书配置</span><br>      <span class="hljs-attr">ssl_certificate</span>     <span class="hljs-string">/etc/nginx/cert/nginx.pem;</span><br>      <span class="hljs-attr">ssl_certificate_key</span> <span class="hljs-string">/etc/nginx/cert/nginx.key;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="不带-SSL-的-nginx-负载均衡配置（不推荐）"><a href="#不带-SSL-的-nginx-负载均衡配置（不推荐）" class="headerlink" title="不带 SSL 的 nginx 负载均衡配置（不推荐）"></a>不带 SSL 的 nginx 负载均衡配置（不推荐）</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">stream</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 轮询负载均衡配置</span><br>  <span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 max_fails=2 fail_timeout=30s;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 max_fails=2 fail_timeout=30s;</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">      # 监听 8883 端口 SSL</span><br>      <span class="hljs-attr">listen</span> <span class="hljs-string">8883;</span><br><span class="hljs-comment">      # 反向代理到 emqx_cluster</span><br>      <span class="hljs-attr">proxy_pass</span> <span class="hljs-string">emqx_cluster;</span><br>      <span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Nginx-重载配置并验证负载均衡"><a href="#Nginx-重载配置并验证负载均衡" class="headerlink" title="Nginx 重载配置并验证负载均衡"></a>Nginx 重载配置并验证负载均衡</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><p>随便打开其中一个节点的 Dashboard，看看集群是否正常运作，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142355321.png" alt="image-20220406142355321"></p><p>使用 MQTTX 创建 4 个相同的连接，指向 mqtts:&#x2F;&#x2F;192.168.100.100:8883，即 nginx 网关所在的服务节点，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142625110.png" alt="image-20220406142625110"></p><p>连上四个连接后再次查看 Dashboard，验证负载均衡是否生效，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220406142909550.png" alt="image-20220406142909550"></p><p>可以看到 4 个连接通过轮询的负载均衡策略被分配到了 3 个节点，至此我们就建立了如下所示的生产集群。</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220406143939.png"></p><h3 id="其他负载均衡策略"><a href="#其他负载均衡策略" class="headerlink" title="其他负载均衡策略"></a>其他负载均衡策略</h3><p>在实际生产中，我们除了简单的轮询负载均衡策略之外，我们还有许多选择，我们只需要修改上面的 upstream 配置即可，</p><p><strong>随机轮询策略</strong></p><p>随机轮询就是从待选列表中随机分配连接，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br>  <span class="hljs-attr">random;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>带权轮询策略</strong></p><p>如果部署的服务器存在性能差异，我们可以通过配置权重 weight 来修改轮询的几率，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883 weight=1;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883 weight=2;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883 weight=3;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>least_conn 策略</strong></p><p>最小连接数策略，优先分配给获得连接数较少的服务器，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br>  <span class="hljs-attr">least_conn;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>IP Hash 策略</strong></p><p>如果有特殊需求，希望同一个客户端连接至同一个服务器，则可以使用 IP Hash 策略。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">emqx_cluster &#123;</span><br><span class="hljs-comment">  # 指定策略为 ip hash</span><br>  <span class="hljs-attr">ip_hash;</span><br><span class="hljs-comment">    # nginx 的三个实例</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.101:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.102:1883;</span><br>      <span class="hljs-attr">server</span> <span class="hljs-string">192.168.100.103:1883;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>其他策略</strong></p><p>上面介绍的都是 Nginx 内置的负载均衡策略，其实还有许多通过第三方插件引入的负载均衡策略，比如 fair 等，本文不做过多介绍。</p>]]></content>
    
    
    <categories>
      
      <category>EMQX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EMQX 快速上手（MQTT协议）</title>
    <link href="/2022/04/06/EMQX/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EMQX%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"/>
    <url>/2022/04/06/EMQX/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EMQX%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="EMQX-介绍"><a href="#EMQX-介绍" class="headerlink" title="EMQX 介绍"></a>EMQX 介绍</h2><p>EMQX 是基于 Erlang&#x2F;OTP 平台开发的开源物联网 MQTT 消息服务器。而 MQTT 实际上是一种应用层协议，用于实现轻量的、发布订阅式的物联网消息协议。事实上，虽然 EMQX 的定位是物联网消息协议 MQTT 的 broker，但是它的处理能力已经超过了它的定义。而在之后的文章中，我们会为读者介绍使用 EMQX 来实现 IM 的推送系统。</p><blockquote><p>本文受限于篇幅，不介绍 MQTT 协议</p></blockquote><h2 id="安装-EMQX"><a href="#安装-EMQX" class="headerlink" title="安装 EMQX"></a>安装 EMQX</h2><p>这里为了方便起见，我们只介绍压缩包安装，也方便利用我们前面所提到的 Centos 集群发布机制，</p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><p>首先我们打开下面的网站，</p><p><a href="https://www.emqx.com/zh/try?product=broker">https://www.emqx.com/zh/try?product=broker</a></p><p>然后我们选择我们对应的版本信息，然后下载压缩包即可，下载完成后进行解压即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip emqx-4.4.2-otp24.1.5-3-el7-amd64.zip<br></code></pre></td></tr></table></figure><p>emqx 目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx/<br>├── bin # 可执行文件的位置<br>├── data # 存放数据的位置<br>├── dynlibs<br>├── erts-12.1.5<br>├── etc # 配置文件位置及插件配置文件位置<br>├── lib<br>├── log # 日志存放位置<br>└── releases<br></code></pre></td></tr></table></figure><h3 id="添加到全局环境变量（可选）"><a href="#添加到全局环境变量（可选）" class="headerlink" title="添加到全局环境变量（可选）"></a>添加到全局环境变量（可选）</h3><p>如果读者不太了解 Centos 的环境变量怎么配置，则可以使用下面的脚本修改执行即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export EMQX_HOME=#读者 EMQX 的安装位置<br>echo &quot;PATH=\$PATH:$EMQX_HOME\bin&quot; &gt; /etc/profile.d/my_emqx.sh<br></code></pre></td></tr></table></figure><p>比如读者的 EMQX 安装位置为 &#x2F;opt&#x2F;module&#x2F;emqx，则对应脚本替换如下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export EMQX_HOME=/opt/module/emqx<br>echo &quot;PATH=\$PATH:$EMQX_HOME/bin&quot; &gt; /etc/profile.d/my_emqx.sh<br></code></pre></td></tr></table></figure><p>接下来就是让环境变量生效即可，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><h3 id="启停命令使用"><a href="#启停命令使用" class="headerlink" title="启停命令使用"></a>启停命令使用</h3><p>对于中间件，我们上手的使用方法肯定无非就是启动，停止，重启啦。</p><blockquote><p>如果读者没有添加环境变量，那么之后的执行命令，读者都应该以绝对或者相对路径来指明 emqx 可执行文件的位置，譬如下列命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./emqx start<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/module/emqx/bin/emqx start<br></code></pre></td></tr></table></figure></blockquote><p>下面我们尝试启动 emqx，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx start<br></code></pre></td></tr></table></figure><p>启动成功后，应该看到输出包含以下内容，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">EMQ X Broker x.x.x is started successfully!<br></code></pre></td></tr></table></figure><p>当修改了配置文件或者其他原因需要重新启动 EMQX 时，使用以下命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx restart<br></code></pre></td></tr></table></figure><p>重启成功后，应该看到输出包含以下内容，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">EMQ X Broker 4.4.2 is stopped: ok<br>EMQ X Broker 4.4.2 is started successfully!<br></code></pre></td></tr></table></figure><p>如果要停止 emqx，可以使用以下命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">emqx stop<br></code></pre></td></tr></table></figure><h3 id="控制台使用"><a href="#控制台使用" class="headerlink" title="控制台使用"></a>控制台使用</h3><p>在启动了 emqx 后，我们可以通过访问 18083 端口来使用控制台，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220404222346716.png" alt="image-20220404222346716"></p><p>其默认的账号密码为 admin 和 public。</p><p>进入到 EMQX 后，我们可以首先将语言改为中文，</p><p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220404222735198.png" alt="image-20220404222735198"></p><p>下面我们来介绍一下 EMQX dashboard 的各项功能吧。</p><ul><li>监控：查看当前运行节点的各项指标</li><li>客户端：查看已经连接的客户端</li><li>主题：查看当前活动的主题</li><li>订阅：查看当前的客户端与主题的订阅情况</li><li>规则引擎：用SQL构建用于消息流的实时处理，本文不做介绍</li><li>统计分析：主题的消息流入流出统计信息</li><li>插件：这里提供了许多 EMQX 的附加功能，本文后续将会使用其中几个插件</li><li>模块</li><li>工具：主要包含 EMQX HTTP API 和 WebSocket 即时功能，其中 WebSocket 是一个基于浏览器的 MQTT 客户端工具</li><li>告警：用于显示一些威胁到 EMQX 稳定运行的事件，比如主机剩余内存告急，CPU 荷载过高等信息。</li><li>通用：这里包含一些用户管理相关功能，一些端口使用的有效信息。</li></ul><h2 id="MQTTX-客户端"><a href="#MQTTX-客户端" class="headerlink" title="MQTTX 客户端"></a>MQTTX 客户端</h2><p>有了 MQTT broker 还不够，我们还需要一个好用的 MQTT Client，那么这个这里推荐官方提供的客户端 MQTTX，</p><p><a href="https://mqttx.app/zh">https://mqttx.app/zh</a></p><p>安装完成后，界面如下所示，使用方法非常简单，点击左侧 + 按钮，即可创建连接，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/20220405013816.png" style="zoom: 50%;" /><p>其连接的高级功能本文不做介绍，里面涉及一些 MQTT 协议的内容，如果读者了解 MQTT 协议，自然理解里面的一些设置的含义。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>作者使用它来连接到本地的 192.168.100.100 虚拟机中的 EMQX，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014144463.png" alt="image-20220405014144463" style="zoom: 67%;" /><p>点击连接后，如果连接成功将会显示如下的内容，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014447704.png" alt="image-20220405014447704" style="zoom: 50%;" /><h3 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h3><p>现在我们再创建一个连接，用来测试之后的订阅与发布功能。现在我们两个连接都已经连接上了 EMQX，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405014810255.png" alt="image-20220405014810255" style="zoom:50%;" /><p>我们通过“添加订阅”功能为两个连接添加同一个订阅，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015208192.png" alt="image-20220405015208192" style="zoom:50%;" /><p>现在我们通过其中一个连接给主题 test- topic 发送消息，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015353716.png" alt="image-20220405015353716" style="zoom:50%;" /><p>我们可以看到另一个连接接收到了新的消息，</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220405015436618.png" alt="image-20220405015436618" style="zoom:50%;" /><p>至此有关 MQTTX 的介绍到此为止。</p>]]></content>
    
    
    <categories>
      
      <category>EMQX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高效配置 Centos 集群环境</title>
    <link href="/2022/04/02/Tool%E6%9D%82%E8%B0%88/Tool%20%E6%9D%82%E8%B0%88%E2%80%94%E2%80%94%E4%BC%98%E9%9B%85%E5%9C%B0%E9%85%8D%E7%BD%AE%20Centos%20%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/04/02/Tool%E6%9D%82%E8%B0%88/Tool%20%E6%9D%82%E8%B0%88%E2%80%94%E2%80%94%E4%BC%98%E9%9B%85%E5%9C%B0%E9%85%8D%E7%BD%AE%20Centos%20%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p><p>⚠ 本文较长，请分期食用，注意实践与理论结合</p><p>图片挂了，呜呜呜～，请各位看客转为阅读公众号文章，</p><p><a href="https://mp.weixin.qq.com/s/IWE9rZ1JzF6tr_uqQKWzCg">https://mp.weixin.qq.com/s/IWE9rZ1JzF6tr_uqQKWzCg</a></p><p>图片晚点补上。</p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在刚拿到服务器的时候，第一个问题就是环境配置。作为一个 Javaer，给新机器配置 JDK 和搭建中间件集群已经是家常便饭的事情了。配置工作是机械的，但是往往因为网络等因素而变得耗时，那有没有一劳永逸的办法呢？本文将为你揭晓答案。</p><h2 id="2-环境与前提条件"><a href="#2-环境与前提条件" class="headerlink" title="2. 环境与前提条件"></a>2. 环境与前提条件</h2><p>本文将会带读者快速实现对三台机器的基础环境配置，并且留下一个<strong>手脚架和实践方法</strong>以供读者配置其他环境使用。</p><ul><li>Windows 11</li><li>VMware Workstation 16</li></ul><p>在这里需要读者准备好 Centos 镜像和 JDK linux 压缩包</p><ul><li>centos：<a href="https://www.centos.org/download/">https://www.centos.org/download/</a></li><li>JDK：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></li></ul><blockquote><p>我的习惯是更加偏向使用压缩包来进行安装，因为压缩包的好处就是安装位置由自己选择，方便统一管理</p></blockquote><h2 id="3-配置-Centos-集群"><a href="#3-配置-Centos-集群" class="headerlink" title="3. 配置 Centos 集群"></a>3. 配置 Centos 集群</h2><p>这里我们将选择搭建 3 台虚拟机来模拟真实的服务器集群环境，读者可以选择自己搭建然后直接跳到第 4 节，也可以选择跟着我的节奏来搭建 centos 集群。最终本节搭建成功的效果如图所示，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/1.png"  /><h3 id="3-1-创建一个-centos-虚拟机"><a href="#3-1-创建一个-centos-虚拟机" class="headerlink" title="3.1 创建一个 centos 虚拟机"></a>3.1 创建一个 centos 虚拟机</h3><blockquote><p>如果你已经创建好了，那么你可以选择跳过本节</p></blockquote><ol><li><p>打开新建虚拟机向导，这里我们选择自定义</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/2.png" alt="image-20220320151931689" style="zoom:80%;" /></li><li><p>点击两次下一步后，这里我们选择创建一个空白的虚拟硬盘，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/3.png" alt="image-20220320160448877" style="zoom:80%;" /></li><li><p>这里因为我下载的是 Centos 7 x64 的镜像，所以我的配置如下所示，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/4.png" style="zoom:80%;" /></li><li><p>配置虚拟机名和存放位置，下一步</p></li><li><p>虚拟机配置（处理器和内存配置），如果你不需要使用可视化操作界面的话，可以调低一点。当然，这些配置之后可以修改，所以不用太担心。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/5.png" alt="image-20220320153030516" style="zoom:80%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/6.png" alt="image-20220320153129741" style="zoom:80%;" /></li><li><p>选择 NAT 网络，这对我们之后配置虚拟网络的非常关键，下一步</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/7.png" alt="image-20220320153313087" style="zoom:80%;" /></li><li><p>IO 控制器和磁盘类型我们不需要做变动，直接下一步就行</p></li><li><p>磁盘配置，大家可以参考我的配置</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/8.png" alt="image-20220320153454705" style="zoom:80%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/9.png" alt="image-20220320160713489" style="zoom:80%;" /></li><li><p>后面的配置都无关紧要了，如果没有什么需要自定义的地方读者可以选择一直下一步到完成</p></li><li><p>配置操作系统镜像<br>到刚创建好的虚拟机，为其配置操作系统镜像，如图所示，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/10.png" style="zoom:67%;" /></li><li><p>启动虚拟机，完成操作系统设置<br>如果读者使用的镜像也是 centos 7 的话，接下来的步骤基本相同。选择好语言和键盘后将会跳转到当前界面，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/11.png" style="zoom:80%;" /><p>我们接下来要在这个界面完成几项设置，</p><ul><li><p>SOFTWARE SELECTION：软件设置，我的习惯是只安装一个最小的，只有命令交互界面的 centos，如果读者有使用 GUI 界面的习惯可以选择另外一个选项。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/12.png" style="zoom:67%;" /></li><li><p>NETWORK &amp; HOST NAME：配置网络，我们要让 centos 能够连接上网络</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/13.png" style="zoom:67%;" /><p>将如图所示开关打开</p></li></ul><p>上述配置完成后我们选择 Begin Installation，之后会跳转到如图界面，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/14.png" style="zoom:80%;" /><p>按照它的指引配置 Root 密码和用户即可，这里作者配置 root 账号密码为 123456</p></li><li><p>安装完进行一波重启，应该就能进入如图所示的命令交互界面了</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/15.png" alt="image-20220320170832373" style="zoom: 80%;" /></li></ol><h3 id="3-2-配置虚拟网络"><a href="#3-2-配置虚拟网络" class="headerlink" title="3.2 配置虚拟网络"></a>3.2 配置虚拟网络</h3><p>下面我们需要配置虚拟网络，配置的目的主要是为了模拟真实的网络环境，让虚拟机在宿主机上拥有自己的静态 ip，并且虚拟机之间能够成功访问彼此。</p><blockquote><p>如果读者计划使用服务器，而不是本地虚拟机来实践的话，可以选择跳过这一节和后面的 3.4 节，在这两节我们主要做了这些工作，</p><ul><li>配置 NAT 网关</li><li>通过克隆创建了三台虚拟机</li></ul></blockquote><ol><li>点开 Vmware Workstation 的虚拟网络编辑器</li></ol><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/16.png" style="zoom:80%;" /><ol start="2"><li>点击更改设置通过 UAC 管理员设置后将会显示如图界面</li></ol><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/17.png" alt="image-20220322221749684" style="zoom: 67%;" /><ol start="3"><li><p>下面我们添加一个虚拟网络 Vmnet8</p><p>点击添加网络，选择 Vmnet8，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/18.png" alt="image-20220322222445596" style="zoom:67%;" /><p>创建成功后，将会如图显示，我们要做几个配置，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/19.png" alt="image-20220322223213216" style="zoom:67%;" /><p>修改后长这样，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/20.png" alt="image-20220322223532826" style="zoom:67%;" /><p>现在我们点进去 NAT 设置，看看网关地址，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/21.png" alt="image-20220322223640034" style="zoom: 67%;" /><p>一般来说如果你和我使用的是相同的配置，我们的网关地址都是 192.168.100.2，至此虚拟网络就配置好了，别忘了确定保存噢~</p></li></ol><h3 id="3-3-配置模板虚拟机网络"><a href="#3-3-配置模板虚拟机网络" class="headerlink" title="3.3 配置模板虚拟机网络"></a>3.3 配置模板虚拟机网络</h3><p>现在让我们进入之前创建的那台 centos 虚拟机，</p><ol><li><p>修改网络配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><blockquote><p>如果这时候提示 vim command not found，则读者需要通过以下命令安装 vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y vim<br></code></pre></td></tr></table></figure></blockquote><p>我们需要修改配置文件中的几项，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改为 static</span><br><span class="hljs-attr">BOOTPROTO</span>=<span class="hljs-string">static</span><br><span class="hljs-comment">### 如果没有以下几项则添加 ###</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.100 </span><br><span class="hljs-comment"># 指定前缀长度</span><br><span class="hljs-attr">PREFIX</span>=<span class="hljs-string">24 </span><br><span class="hljs-comment"># 指定网关</span><br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-string">192.168.100.2 </span><br><span class="hljs-comment"># 指定 DNS</span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-string">192.168.100.2 </span><br></code></pre></td></tr></table></figure><p>保存后重启虚拟机</p></li><li><p>测试是否已经成功配置网络</p><p>我们在宿主机尝试 ping 配置好的虚拟机 192.168.100.100，如下图所示，可以看到结果如下所示。</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/22.png" alt="image-20220322225737162" style="zoom:67%;" /></li></ol><h3 id="3-4-克隆虚拟机"><a href="#3-4-克隆虚拟机" class="headerlink" title="3.4 克隆虚拟机"></a>3.4 克隆虚拟机</h3><p>上面我们创建了一个模板虚拟机，现在我们要用它来创建两个 ip 分别为 192.168.100.101 和 192.168.100.102 的虚拟机</p><ol><li><p>选择克隆菜单</p><img src="https://raw.githubusercontent.com/JacketLWJ/my_picgo/master/img/image-20220322231806931.png" style="zoom:80%;" /></li><li><p>接下来的步骤通过图示演示</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/24.png" style="zoom:67%;" /><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/25.png" alt="image-20220322232010039" style="zoom:67%;" /><p>下面配置虚拟机名称和存储位置点击完成即可。</p><ol start="3"><li><p>通过上面的步骤克隆两个虚拟机后，我们只需要将之前的网络配置文件中的静态 IP 地址分别修改即可。这里我们分别修改为 192.168.100.101 和 192.168.100.102</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">...</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.101 </span><br><span class="hljs-attr">...</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">...</span><br><span class="hljs-comment"># 指定静态 ip</span><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-string">192.168.100.102</span><br><span class="hljs-attr">...</span><br></code></pre></td></tr></table></figure></li><li><p>配置完成后，重启虚拟机，这时候应该有三台虚拟机正在运行，现在我们要验证三台虚拟机是否能够互通</p><blockquote><p>这里读者使用了 XShell 来作为 SSH 工具，当然实际上直接使用虚拟机的 Terminal 也是没有问题的</p></blockquote><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/26.png" alt="image-20220323141303356" style="zoom: 80%;" /><p>让虚拟机之间互相 ping 一下，看看是否能够联通</p></li></ol></li></ol><h2 id="4-配置-JDK-环境"><a href="#4-配置-JDK-环境" class="headerlink" title="4. 配置 JDK 环境"></a>4. 配置 JDK 环境</h2><p>本节我们首先会配置其中一台虚拟机的环境，这里我们配置 192.168.100.100 的 JDK 环境</p><p>按照作者习惯，一般软件压缩包会放置在 &#x2F;opt&#x2F;software 目录下，而其安装位置选择在 &#x2F;opt&#x2F;module，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/software /opt/module<br></code></pre></td></tr></table></figure><p>进入 software，然后将 JDK 压缩包上传上去，上传成功后我们通过 ll 查看，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/27.png" alt="image-20220323145427597" style="zoom:80%;" /><p>进行解压，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf /opt/software/jdk-8u321-linux-x64.tar.gz -C /opt/module/<br></code></pre></td></tr></table></figure><p>进入解压好的 jdk 目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/module/jdk1.8.0_321/<br></code></pre></td></tr></table></figure><p>pwd，然后复制一下路径，配置环境变量时会用到。</p><p>现在我们进入环境变量目录，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/profile.d/<br></code></pre></td></tr></table></figure><p>创建一个自定义的脚本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim my_env.sh<br></code></pre></td></tr></table></figure><p>将下面的内容输入到文件中进行保存，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export JAVA_HOME=/opt/module/jdk1.8.0_321/<br>export PATH=$PATH:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>使得环境变量生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>检查 Java 环境是否生效，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><p><img src="C:/Users/11740/AppData/Roaming/Typora/typora-user-images/image-20220324013931610.png" alt="image-20220324013931610"></p><p>这里可能有读者有疑问，为什么不直接修改 &#x2F;etc&#x2F;profile 文件？而是通过在 profile.d 目录下创建一个自己的配置文件。首先，是不推荐大家修改 profile，相较于创建一个专门的文件来管理自定义环境变量，追加式地修改 profile 不容易维护，并且容易修改错误，导致其他系统变量出现问题。然后我们再来分析一下 profile.d 下自定义的文件是如何生效的？</p><h2 id="5-Linux-集群分发介绍"><a href="#5-Linux-集群分发介绍" class="headerlink" title="5. Linux 集群分发介绍"></a>5. Linux 集群分发介绍</h2><h3 id="5-1-SCP-命令介绍"><a href="#5-1-SCP-命令介绍" class="headerlink" title="5.1 SCP 命令介绍"></a>5.1 SCP 命令介绍</h3><p><code>scp</code> 是 secure copy 的简写，用于 linux 下远程文件拷贝的命令，功能和 cp 是类似的，只不过强制使用 SSH 连接加密的方式。通常来说如果不配置服务器之间的免密登录，那么每次使用命令都将需要输入目标服务器的账户密码。</p><p><code>scp</code> 的命令的简单使用格式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r local_path remote_username@remote_ip:remote_path<br></code></pre></td></tr></table></figure><ul><li>local_path：本地文件路径</li><li>remote_username：远程服务器的用户名</li><li>remote_ip：远程服务器 ip 地址</li><li>remote_path：要拷贝到的远程路径</li></ul><p>下面我们简单使用一下，我们尝试使用这条命令从 192.168.100.100 <strong>拷贝</strong> JDK 安装目录到 192.168.100.101，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r /opt/module/ root@192.168.100.101:/opt/module/<br></code></pre></td></tr></table></figure><p>这时候会提示你非对称加密指纹的警告，我们输入 yes 再继续，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/image-20220323225308534.png" style="zoom:80%;" /><p>接下来会提示你需要输入密码才能继续，输入密码回车后，你将会看到一大段输入，和 cp 命令的输出是一个道理的，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/30.png" alt="image-20220323225328417" style="zoom:80%;" /><blockquote><p>重新执行 <code>scp</code> 命令之后还是需要重新输入密码的，这很麻烦，在第六节，作者将会介绍如何配置免密登录</p></blockquote><p>我们到 192.168.100.101 的目录下验证是否已经拷贝成功，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/31.png" alt="image-20220323230539273" style="zoom:80%;" /><p>细心的读者再重复执行一次拷贝命令，会发现 <code>scp</code> 命令会重复完整地拷贝整个 module 并以覆盖的形式传送到指定服务器，我们将会看到和第一次执行 <code>scp</code> 命令一样的输出。换言之，<code>scp</code> 命令无论远程服务器指定目录下是否已经存在相同的文件，<code>scp</code> 都会重复地拷贝，这样带来许多无用的拷贝工作，造成了很多额外的耗时。</p><blockquote><p>事实上，我们希望找到一种类似 SVN 或者 Git 版本控制工具的同步方式，而不需要每一次都进行完整的拷贝，那么接下来介绍的命令将会以一种镜像同步的方式解决集群分发问题。</p></blockquote><h3 id="5-2-RSYNC-命令介绍"><a href="#5-2-RSYNC-命令介绍" class="headerlink" title="5.2 RSYNC 命令介绍"></a>5.2 RSYNC 命令介绍</h3><p><code>rsync</code> 主要用于备份和镜像同步。相较于 <code>scp</code>，它具备速度更快、避免复制相同内容等优点。</p><p><code>rsync</code> 的命令的简单使用格式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av local_path remote_username@remote_ip:remote_path<br></code></pre></td></tr></table></figure><p>现在我们尝试使用 <code>rsync</code> 来将 JDK <strong>同步</strong>到 192.168.100.102，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /opt/module/ root@192.168.100.102:/opt/module/<br></code></pre></td></tr></table></figure><blockquote><p>读者可能需要先安装一下 <code>rsync</code>，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y rsync<br></code></pre></td></tr></table></figure></blockquote><p>第一次执行的前两步和前面的 <code>scp</code> 一样，都是要保存远程服务器的密钥指纹和输入密码，后续执行就只需要输入密码了。</p><p>输入密码回车执行后，由于是第一次同步 module 路径，那么第一次肯定是全量同步的，也就是和拷贝是没有什么去别的。当我们重复执行这条命令后，你会发现和 <code>scp</code> 有所不同，</p><img src="C:/Users/11740/Desktop/Tool%E6%9D%82%E8%B0%88%20centos/32.png" style="zoom:80%;" /><p>命令会很快执行完毕，因为 <code>rsync</code> 使用的是增量同步的方式，由于文件没有经过修改，那么 <code>rsync</code> 不会产生任何文件拷贝操作。</p><p>现在我们尝试同步 &#x2F;etc&#x2F;profile.d&#x2F;my_env.sh 配置文件到其他服务器中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /etc/profile.d/my_env.sh root@192.168.100.101:/etc/profile.d/<br>rsync -av /etc/profile.d/my_env.sh root@192.168.100.102:/etc/profile.d/<br></code></pre></td></tr></table></figure><p>读者将会看到以下输出，</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220323234300219.png" style="zoom:80%;" /><p>现在我们往配置文件中添加一些注释，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Java Home</span><br><span class="hljs-attr">export</span> <span class="hljs-string">JAVA_HOME=/opt/module/jdk1.8.0_321/</span><br><span class="hljs-comment"># add to path</span><br><span class="hljs-attr">export</span> <span class="hljs-string">PATH=$PATH:$JAVA_HOME/bin</span><br></code></pre></td></tr></table></figure><p>再次执行 rsync，只不过这时候我们选择同步整个 profile.d 路径，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av /etc/profile.d/ root@192.168.100.101:/etc/profile.d/<br></code></pre></td></tr></table></figure><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/20220323235123.png" style="zoom:80%;" /><p>读者会发现 <code>rsync</code> 只同步了被修改的 <code>my_env.sh</code> 文件，我们也就验证了 <code>rsync</code> 增量同步的特性。这个特性非常有用，加入我们在 &#x2F;opt&#x2F;module 和 &#x2F;etc&#x2F;profile.d 目录下分别放置着非常多的软件目录和配置文件，<strong>rsync 能够帮助我们实现修改一处然后同步到多处的需求</strong>。</p><h3 id="5-3-集群分发脚本"><a href="#5-3-集群分发脚本" class="headerlink" title="5.3 集群分发脚本"></a>5.3 集群分发脚本</h3><p>通过上面我们介绍了 rsync 命令的使用，在使用中我们发现一个问题，如果需要同步一个路径到多个服务器时，我们需要执行下面的多条命令，并且<strong>如果需要同步的服务器越多，命令执行的次数就越多，</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -av local_path root@192.168.100.101:remote_path<br>rsync -av local_path root@192.168.100.102:remote_path<br>...<br></code></pre></td></tr></table></figure><p>我们能不能有一种一劳永逸的办法，我只需要给命令提供路径，它就自动帮我同步到所有节点呢？那这就是 shell 脚本的命令了，下面提供一个脚本供读者使用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断参数是否足够</span><br>if [ $# -lt 1 ]<br>then<br>    echo Not Enough Arguement!<br>    exit;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">遍历集群所有 ip</span><br>for host in 192.168.100.100 192.168.100.101 192.168.100.102<br>do<br>    echo ====================  $host  ====================<br>    <br>    # 遍历所有目录<br>    for file in $@<br>    do<br>        # 判断文件是否存在<br>        if [ -e $file ]<br>            then<br>                # 获取父目录<br>                pdir=$(cd -P $(dirname $file); pwd)<br>                # 获取当前文件的名称<br>                fname=$(basename $file)<br>                ssh $host &quot;mkdir -p $pdir&quot;<br>                # 循环执行 rsync 命令<br>                rsync -av $pdir/$fname $host:$pdir<br>            else<br>                echo $file does not exists!<br>        fi<br>    done<br>done<br></code></pre></td></tr></table></figure><p>如果读者使用了不同的 ip 地址，则只需要修改脚本这一处为你的 ip 列表，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">...<br>for host in ip1 ip2 ip3 ... ipn<br>...<br></code></pre></td></tr></table></figure><p>下面我们来使用这个脚本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd<br>vim syncall<br></code></pre></td></tr></table></figure><p>然后将上面的脚本写入文件中并保存。</p><p>修改脚本执行权限，使其能够被执行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x syncall<br></code></pre></td></tr></table></figure><p>验证脚本是否能够被执行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./syncall /etc/profile.d/<br></code></pre></td></tr></table></figure><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324001525055.png" alt="image-20220324001525055" style="zoom: 67%;" /><p>可以看到除了要处理密钥指纹和输入多次密码之外，脚本是正常执行的。</p><p>拷贝到 bin 目录以便全局可用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp syncall /bin<br></code></pre></td></tr></table></figure><p>至此你已经能够在任何地方使用这个集群分发脚本了。</p><h2 id="6-SSH-免密登录"><a href="#6-SSH-免密登录" class="headerlink" title="6. SSH 免密登录"></a>6. SSH 免密登录</h2><p>因为篇幅问题，我们不在本文介绍 SSH 免密登录原理，直接提供步骤给大家。</p><ol><li><p>生成本机的公私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd .ssh/<br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>然后直接敲回车，让它做默认选择</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324002139567.png" alt="image-20220324002139567" style="zoom: 67%;" /></li><li><p>拷贝公钥到指定服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id 192.168.100.100<br>ssh-copy-id 192.168.100.101<br>ssh-copy-id 192.168.100.102<br></code></pre></td></tr></table></figure><p>期间会需要输入指定服务器的 root 密码</p><blockquote><p>注意，如果读者希望其他服务器也能互相无密登录，则需要到 101 和 102 的服务器上重复执行上面的步骤。如果读者希望不适用 root 账号来做无密登录，则需要切换到其他用户账户，并重复上面步骤即可。</p></blockquote></li><li><p>使用集群分发来验证是否配置成功</p><img src="C:/Users/11740/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/image-20220324002801484.png" alt="image-20220324002801484" style="zoom:80%;" /><p>一路畅通~</p></li></ol><h2 id="7-总结经验"><a href="#7-总结经验" class="headerlink" title="7. 总结经验"></a>7. 总结经验</h2><p>本文核心的内容是 <code>SCP</code> 与 <code>RSYNC</code> 的使用与<strong>集群分发脚本</strong>。经验之谈，如果想要快速配置一台新购买的服务器，那么我建议本地保存有一些常用的模板机，然后通过在远程服务器安装 <code>rsync</code> ，并通过启动模板机做集群分发即可快速完成模板配置。</p>]]></content>
    
    
    <categories>
      
      <category>Tool 杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计数器表</title>
    <link href="/2022/03/26/MySQL/MySQL%20%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E8%81%8A%E8%81%8A%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/"/>
    <url>/2022/03/26/MySQL/MySQL%20%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E8%81%8A%E8%81%8A%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪美味的技术餐</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多论坛或者电商系统都具备点赞数、评论数、浏览数等“计数”功能，好的设计可以实现不低并发量且精确的计数器需求。本文将抛开中间件等额外的设计，从 MySQL 出发简单聊聊如何设计计数器表。</p><h2 id="糟糕的设计"><a href="#糟糕的设计" class="headerlink" title="糟糕的设计"></a>糟糕的设计</h2><p>下面以论坛系统为例子介绍其中一种计数器表设计，下面给出这个最简单的设计，我们有这样一个表 post，承担着主要的帖子读写业务，其中一个高频写入功能为帖子的点赞计数功能。</p><table><thead><tr><th>post_id</th><th>post_content</th><th>··· 其他列 ···</th><th>likes</th></tr></thead><tbody><tr><td>1</td><td>## content ##</td><td>···</td><td>3</td></tr><tr><td>2</td><td>## content ##</td><td>···</td><td>5</td></tr><tr><td>3</td><td>## content ##</td><td>···</td><td>2</td></tr><tr><td>···</td><td>···</td><td>···</td><td>···</td></tr></tbody></table><p>这个设计对于并发量很低的系统来说，可能没有什么问题，但是当并发量增加时，点赞的并发性能将会成为系统的瓶颈。</p><blockquote><p>点赞是用户无意识的行为，在社交论坛上，点赞的触发次数远大于其他功能，对点赞计数的优化是非常重要的。</p></blockquote><p>首先我们必须明确，我们增加某个点赞计数时使用的 SQL 语句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> post_id <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><p>我们知道，一个事务在更新某一行时，如果 where 子句使用的是索引，那么该事务需要首先获取该行的互斥锁。多个并发事务想要增加同一个帖子的点赞量时，这种设计将会使得这些事务只能串行执行。如图所示，</p><img src="C:/Users/11740/Desktop/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/1.png"  /><p>如果同一时间出现热门帖子时，多个用户同时点赞将会导致大量的数据库连接处于等待状态。为了优化这种事务串行的问题，我们介绍一种低成本且有效的方案——<strong>计数器表</strong>。</p><h2 id="计数器表优化"><a href="#计数器表优化" class="headerlink" title="计数器表优化"></a>计数器表优化</h2><p>现在我们希望将帖子的点赞计数移到另外的表 post_counter，并且做一些冗余设计。</p><table><thead><tr><th>post_id</th><th>slot</th><th>likes</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>3</td></tr><tr><td>1</td><td>1</td><td>5</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>4</td></tr><tr><td>1</td><td>4</td><td>2</td></tr><tr><td>2</td><td>0</td><td>3</td></tr><tr><td>2</td><td>1</td><td>5</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>3</td><td>6</td></tr><tr><td>2</td><td>4</td><td>3</td></tr><tr><td>···</td><td></td><td>···</td></tr></tbody></table><p>DDL语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> post_counter<br>(<br>    post_id <span class="hljs-type">int</span>              <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    slot    tinyint unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    likes   <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><p>对于每个 post_id，我们<strong>预先创建 5 行数据，同一个 post_id 的不同行用 slot（槽）标识</strong>。如果我们要进行增加点赞数，其 SQL 语句如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post_counter <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> slot <span class="hljs-operator">=</span> rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>相应的减少点赞数如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> post_counter <span class="hljs-keyword">set</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> slot <span class="hljs-operator">=</span> rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>读者很容易发现，并发事务对同一个帖子的点赞数更新操作将会被随机分散到 5 行数据中，如图所示，</p><img src="C:/Users/11740/Desktop/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8/2.png"  /><p>这样能够很好地解决前面所提到的并发事务串行操作的问题。如果我们要获取一个帖子的点赞数，我们只需要做一个聚合查询即可，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(likes) <span class="hljs-keyword">from</span> post_counter <span class="hljs-keyword">where</span> post_id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p><strong>每个帖子都预先创建 5 行会不会导致表的行数过多？</strong></p><p>我们知道有个帖子可能发出来很长一段时间都没有人点赞，或者点赞数稀少，对于这种情况，预留 5 行会显得比较多余。于是，我们可以选择 update 的时候动态创建，这时候我们可以使用 on duplicate key 子句来解决这个需求。因此新的增加点赞语句如下所示，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> post_counter (post_id, likes, slot) <span class="hljs-keyword">values</span>(?, <span class="hljs-number">1</span>, rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span>) <span class="hljs-keyword">on</span> duplicate key <span class="hljs-keyword">update</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>相应的减少点赞数的语句如下，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> post_counter (post_id, likes, slot) <span class="hljs-keyword">values</span>(?, <span class="hljs-number">-1</span>, rand() <span class="hljs-operator">*</span> <span class="hljs-number">5</span>) <span class="hljs-keyword">on</span> duplicate key <span class="hljs-keyword">update</span> likes <span class="hljs-operator">=</span> likes <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了计数器表的设计方法，其适用于各种高频的计数需求。本文为了简单演示，使用的随机数窗口为 5，实际生产中，读者可以通过逐步增加窗口值大小，并通过压力测试来查看锁等待时间，以找到合适当前业务的窗口大小。</p><p>至于有关 Redis 的高并发点赞计数我们以后再聊。不过作者认为，任何优化都应该优先考虑数据库层面的优化，在数据库层面优化没有达标的情况下，通过引入中间件缓存不过是堆积成本的暴力方法罢了。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java序列化源码解析（一）</title>
    <link href="/2022/03/20/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/03/20/%E7%88%86%E8%82%9D%E6%BA%90%E7%A0%81/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公众号：技术小厨师</p><p>关注小厨师，烹饪高超的技术餐</p><p>掘金原文：<a href="https://juejin.cn/post/6987962113788493831">https://juejin.cn/post/6987962113788493831</a> </p></blockquote><h3 id="Java如何得到-suid-的？"><a href="#Java如何得到-suid-的？" class="headerlink" title="Java如何得到 suid 的？"></a>Java如何得到 suid 的？</h3><p>了解过序列化的同学肯定知道，<code>suid</code> 在反序列化时侯有两个，一个是本地类计算出来的 <code>suid</code>，一个是从序列化字节流中读取的 <code>suid</code>，我们的分析也是针对这两种进行展开。</p><h3 id="1-从异常抛出开始"><a href="#1-从异常抛出开始" class="headerlink" title="1. 从异常抛出开始"></a>1. 从异常抛出开始</h3><p>为了寻找源码分析的思路，我们可以通过引发异常开始</p><h4 id="1-1-创建定义一个可序列化的类"><a href="#1-1-创建定义一个可序列化的类" class="headerlink" title="1.1 创建定义一个可序列化的类"></a>1.1 创建定义一个可序列化的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-comment">// getter &amp; setter &amp; toString</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-运行序列化方法"><a href="#1-2-运行序列化方法" class="headerlink" title="1.2 运行序列化方法"></a>1.2 运行序列化方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;player&quot;</span>, <span class="hljs-number">21</span>);<br>    user.setName(<span class="hljs-string">&quot;player&quot;</span>);<br>    user.setAge(<span class="hljs-number">21</span>);<br>    System.out.println(user);<br>    FileSerializeUtil.serialize(user, <span class="hljs-string">&quot;user.obj&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object object, String filepath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filepath))) &#123;<br>        objectOutputStream.writeObject(object);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.warning(<span class="hljs-string">&quot;serialize: fail to serialize object to &quot;</span> + filepath);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-做点手脚"><a href="#1-3-做点手脚" class="headerlink" title="1.3 做点手脚"></a>1.3 做点手脚</h4><p>添加一个成员变量到 User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-运行反序列化方法"><a href="#1-4-运行反序列化方法" class="headerlink" title="1.4 运行反序列化方法"></a>1.4 运行反序列化方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) FileSerializeUtil.deserialize(<span class="hljs-string">&quot;user.obj&quot;</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String filepath)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filepath))) &#123;<br>        <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        logger.warning(<span class="hljs-string">&quot;deserialize: file to deserialize object from &quot;</span> + filepath);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-触发异常，查看异常信息"><a href="#1-5-触发异常，查看异常信息" class="headerlink" title="1.5 触发异常，查看异常信息"></a>1.5 触发异常，查看异常信息</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Exception in thread <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-keyword">java.io.InvalidClassException: </span>serial.User<span class="hljs-comment">; local class incompatible: stream classdesc serialVersionUID = 8985745470054656491, local class serialVersionUID = -4967160969146043535</span><br><span class="hljs-built_in">at</span> <span class="hljs-keyword">java.base/java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:715)</span><br><span class="hljs-keyword"></span>...<br></code></pre></td></tr></table></figure><p>由此我们可以从 715 行开始我们的故事</p><h3 id="2-主干源码分析"><a href="#2-主干源码分析" class="headerlink" title="2. 主干源码分析"></a>2. 主干源码分析</h3><h4 id="2-1-initNonProxy-分析"><a href="#2-1-initNonProxy-分析" class="headerlink" title="2.1 initNonProxy()分析"></a>2.1 <code>initNonProxy()</code>分析</h4><p>为了确定本地的 <code>serialVersionUID</code> 和来自序列化字节流的 <code>serialVersionUID</code> 是如何获得的，在 <code>ObjectStreamClass</code> 类中我们找到了抛出异常的地方，在 <code>initNonProxy()</code> 有这样一段判断代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initNonProxy</span><span class="hljs-params">(ObjectStreamClass model,</span><br><span class="hljs-params">                      Class&lt;?&gt; cl,</span><br><span class="hljs-params">                      ClassNotFoundException resolveEx,</span><br><span class="hljs-params">                      ObjectStreamClass superDesc)</span><br>        <span class="hljs-keyword">throws</span> InvalidClassException<br>    &#123;<br>    <span class="hljs-comment">// (1) suid 的值在这里获得的</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">suid</span> <span class="hljs-operator">=</span> Long.valueOf(model.getSerialVersionUID());<br>    ...<br>        <span class="hljs-keyword">if</span> (cl != <span class="hljs-literal">null</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// 异常在这里抛出</span><br>            <span class="hljs-keyword">if</span> (model.serializable == osc.serializable &amp;&amp;<br>                    !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;<br>                <span class="hljs-comment">// (2) osc 也是通过 getSerialVersionUID() 得到序列化</span><br>                    suid != osc.getSerialVersionUID()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidClassException</span>(osc.name,<br>                        <span class="hljs-string">&quot;local class incompatible: &quot;</span> +<br>                                <span class="hljs-string">&quot;stream classdesc serialVersionUID = &quot;</span> + suid +<br>                                <span class="hljs-string">&quot;, local class serialVersionUID = &quot;</span> +<br>                                osc.getSerialVersionUID());<br>            &#125;<br>            ...<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常产生的原因在于 <code>suid</code> 和 <code>osc.getSerialVersionUID()</code> 不相等。而我们可以知道，两者本质上都调用了 <code>getSerialVersionUID()</code> 方法，我们断定该方法中一定有某种判断。下面我们对 <code>getSerialVersionUID()</code> 方法展开分析。</p><h4 id="2-2-getSerialVersionUID-分析"><a href="#2-2-getSerialVersionUID-分析" class="headerlink" title="2.2 getSerialVersionUID() 分析"></a>2.2 <code>getSerialVersionUID()</code> 分析</h4><p>首先我们注意到方法的文档注释第一行，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Return</span> the serialVersionUID <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">class</span>.<br></code></pre></td></tr></table></figure><p>很显然，告诉我们这个方法返回的类的 <code>serialVersionUID</code> 。我们在源码中 debug 也可以得到 <code>computeDefaultSUID()</code> 返回的即为本地类的 <code>suid</code>，</p><p>该方法的源代码如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSerialVersionUID</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// REMIND: synchronize instead of relying on volatile?</span><br>    <span class="hljs-keyword">if</span> (suid == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isRecord)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br><br>        suid = AccessController.doPrivileged(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Long&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> computeDefaultSUID(cl);<br>                &#125;<br>            &#125;<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> suid.longValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加清楚发现两者调用的不同，我们 debug 看看，</p><p>对于（1）处 <code>suid</code>，</p><p><img src="C:/Users/11740/Desktop/1"></p><p>对于（2）处 <code>osc.getSerialVersionUID()</code> 则有两种可能，</p><ul><li><p><code>User</code> 类中没有自定义 <code>serialVersionUID()</code></p><p><img src="C:/Users/11740/Desktop/2"></p></li><li><p><code>User</code> 类中自定义了 <code>serialVersionUID()</code></p><p><img src="C:/Users/11740/Desktop/3"></p></li></ul><p>我们很容易理解就是<strong>本地序列化类的 UID</strong> 和<strong>反序列化字节流 UID</strong> 都是通过这个方法来获得的。对于<strong>没有自定义的本地的 UID</strong>将会走 if 中的 <code>computeDefaultSUID()</code> 方法进行计算类的 SUID，对于自定义 SUID 和字节流中的 SUID，将会直接返回。</p><blockquote><p>关于 <code>computeDefaultSUID()</code> 的详解可以阅读下文，现在我们先继续讲主线内容</p></blockquote><p>那么我们会有疑问，既然不走 <code>computeDefaultSUID()</code>，那么自定义 SUID 和字节流中的 SUID 是从哪得到的呢？我们通过 IDEA 强大的检索功能，我们可以看看引用了 <code>suid</code> 的地方，</p><p><img src="C:/Users/11740/Desktop/4"></p><p><img src="C:/Users/11740/Desktop/5"></p><ul><li>蓝色标注的是我们<strong>没有自定义 suid 类的计算路径</strong></li><li>目测红色 <code>getDeclaredSUID()</code> 是获取自定义（声明）的 <code>suid</code></li><li>红色 <code>in.readLong()</code> 是从文件输入流中获取的</li></ul><p>下面我们分析获取自定义声明的 <code>suid</code> 来印证我们的猜测。</p><blockquote><p><code>in.readLong()</code> 部分我们不做分析，因为继续进入将会进入 I&#x2F;O 部分的 Java 类，这里简单理解就是通过输入流从文件中读取一个 <code>long</code> 类型整数。</p></blockquote><h4 id="2-3-获取自定义（声明的）suid"><a href="#2-3-获取自定义（声明的）suid" class="headerlink" title="2.3 获取自定义（声明的）suid"></a>2.3 获取自定义（声明的）suid</h4><h5 id="2-3-1-ObjectStreamClass-分析"><a href="#2-3-1-ObjectStreamClass-分析" class="headerlink" title="2.3.1 ObjectStreamClass() 分析"></a>2.3.1 <code>ObjectStreamClass()</code> 分析</h5><p>通过 IDEA 跳转，我们来到了调用 <code>getDeclaredSUID()</code> 的地方，看了看这个方法的注释，</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Creates <span class="hljs-keyword">local</span> <span class="hljs-built_in">class</span> descriptor representing <span class="hljs-keyword">given</span> <span class="hljs-built_in">class</span>.<br></code></pre></td></tr></table></figure><p>大概的意思是，创建一个对应类的描述符。其他的细节我们不需要过分关注，我们只需要关注 if … else 条件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-comment">// 判断是否实现 Serializable 接口    </span><br>serializable = Serializable.class.isAssignableFrom(cl);<br>...<br><span class="hljs-keyword">if</span> (serializable) &#123;<br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            ...<br>            suid = getDeclaredSUID(cl);<br>            ...<br>        &#125;<br>    &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果没有实现 suid = 0</span><br>    suid = Long.valueOf(<span class="hljs-number">0</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出，对于没有实现 <code>Serializable</code> 的类来说，默认分配的 <code>suid</code> 是 0，对于实现了的类来说，走 <code>getDeclaredSUID()</code> 得到 <code>suid</code>。</p><h5 id="2-3-2-getDeclaredSUID-分析"><a href="#2-3-2-getDeclaredSUID-分析" class="headerlink" title="2.3.2 getDeclaredSUID() 分析"></a>2.3.2 <code>getDeclaredSUID()</code> 分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getDeclaredSUID</span><span class="hljs-params">(Class&lt;?&gt; cl)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射得到成员变量 serialVersionUID</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> cl.getDeclaredField(<span class="hljs-string">&quot;serialVersionUID&quot;</span>);<br>        <span class="hljs-comment">// 检查成员变量 serialVersionId 是否是静态常量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> Modifier.STATIC | Modifier.FINAL;<br>        <span class="hljs-keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;<br>            f.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 真正得到本地类自定义 suid 的地方</span><br>            <span class="hljs-keyword">return</span> Long.valueOf(f.getLong(<span class="hljs-literal">null</span>));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法代码并不多，首先通过反射得到成员变量 <code>serialVersionUID</code>，判断其是否是静态常量，然后通过反射得到它的值，就这么简单。看吧，获取自定义（声明）的 <code>suid</code> 已经分析完毕了。</p><h3 id="3-默认计算类-suid-的方法-computeDefaultSUID"><a href="#3-默认计算类-suid-的方法-computeDefaultSUID" class="headerlink" title="3. 默认计算类 suid 的方法 computeDefaultSUID()"></a>3. 默认计算类 suid 的方法 <code>computeDefaultSUID()</code></h3><p>这个方法是在类没有自定义 <code>serialVersionUID</code> 的情况下用于根据类的“信息”来计算 <code>suid</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">computeDefaultSUID</span><span class="hljs-params">(Class&lt;?&gt; cl)</span> &#123;<br>    <span class="hljs-comment">// 检查是否是代理对象和是否是 Serializable 的子类或子接口</span><br>    <span class="hljs-keyword">if</span> (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将输出缓冲到字节数组中</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-comment">// 这里我们可以理解为 dout 将输出缓存到 bout</span><br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bout);<br><br>        <span class="hljs-comment">// 类名写入字节数组</span><br>        dout.writeUTF(cl.getName());<br><br>        <span class="hljs-comment">// 获取类名修饰符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">classMods</span> <span class="hljs-operator">=</span> cl.getModifiers() &amp;<br>            (Modifier.PUBLIC | Modifier.FINAL |<br>             Modifier.INTERFACE | Modifier.ABSTRACT);<br><br>        <span class="hljs-comment">// 获取类成员方法</span><br>        Method[] methods = cl.getDeclaredMethods();<br>        <br>        <span class="hljs-keyword">if</span> ((classMods &amp; Modifier.INTERFACE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果类是接口</span><br>            classMods = (methods.length &gt; <span class="hljs-number">0</span>) ?<br>                <span class="hljs-comment">// 如果存在方法就与抽象修饰符进行或运算</span><br>                (classMods | Modifier.ABSTRACT) :<br>            <span class="hljs-comment">// 不存在方法就与抽象修饰符的反码进行与运算</span><br>                (classMods &amp; ~Modifier.ABSTRACT);<br>        &#125;<br>        <span class="hljs-comment">// 类修饰符写入字节数组</span><br>        dout.writeInt(classMods);<br><br>        <span class="hljs-keyword">if</span> (!cl.isArray()) &#123;<br>            <span class="hljs-comment">// 补偿对于数组的处理，对于数组类型将会得到 Cloneable 和 Serializable，所以数组不必走进来</span><br>            Class&lt;?&gt;[] interfaces = cl.getInterfaces();<br>            String[] ifaceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[interfaces.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interfaces.length; i++) &#123;<br>                ifaceNames[i] = interfaces[i].getName();<br>            &#125;<br>            <span class="hljs-comment">// 对接口名进行排序，避免对于同样的接口数组产生不同的写入</span><br>            Arrays.sort(ifaceNames);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ifaceNames.length; i++) &#123;<br>                <span class="hljs-comment">// 接口名写入字节数组</span><br>                dout.writeUTF(ifaceNames[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取成员变量</span><br>        Field[] fields = cl.getDeclaredFields();<br>        MemberSignature[] fieldSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[fields.length];<br>        <span class="hljs-comment">// 获取成员变量的签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>            fieldSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(fields[i]);<br>        &#125;<br>        Arrays.sort(fieldSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-comment">// 按照成员变量名进行排序</span><br>                <span class="hljs-keyword">return</span> ms1.name.compareTo(ms2.name);<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 对成员变量进行处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> fieldSigs[i];<br>            <span class="hljs-comment">// 得到成员变量修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |<br>                 Modifier.TRANSIENT);<br>            <span class="hljs-comment">// 非私有则进行写入</span><br>            <span class="hljs-keyword">if</span> (((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) ||<br>                <span class="hljs-comment">// 如果是 static 或 transient 则写入</span><br>                ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == <span class="hljs-number">0</span>))<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 也就是说，在这里如果是非私有则一定写入，如果是私有但满足 static 或 transient 才写入</span><br><span class="hljs-comment">                 */</span><br>            &#123;<br>                <span class="hljs-comment">// 签名信息写入字节数组</span><br>                dout.writeUTF(sig.name);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 静态类则写入</span><br>        <span class="hljs-keyword">if</span> (hasStaticInitializer(cl)) &#123;<br>            dout.writeUTF(<span class="hljs-string">&quot;&lt;clinit&gt;&quot;</span>);<br>            dout.writeInt(Modifier.STATIC);<br>            dout.writeUTF(<span class="hljs-string">&quot;()V&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取构造方法</span><br>        Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();<br>        MemberSignature[] consSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[cons.length];<br>        <span class="hljs-comment">// 获取构造方法签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cons.length; i++) &#123;<br>            consSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(cons[i]);<br>        &#125;<br>        <span class="hljs-comment">// 对构造方法签名进行排序</span><br>        Arrays.sort(consSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-keyword">return</span> ms1.signature.compareTo(ms2.signature);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; consSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> consSigs[i];<br>            <span class="hljs-comment">// 获取构造方法修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL |<br>                 Modifier.SYNCHRONIZED | Modifier.NATIVE |<br>                 Modifier.ABSTRACT | Modifier.STRICT);<br>            <span class="hljs-comment">// 如果是非私有构造方法则进行写入</span><br>            <span class="hljs-keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) &#123;<br>                dout.writeUTF(<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature.replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>));<br>            &#125;<br>        &#125;<br><br>        MemberSignature[] methSigs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>[methods.length];<br>        <span class="hljs-comment">// 获取方法的签名</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>            methSigs[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberSignature</span>(methods[i]);<br>        &#125;<br>        <span class="hljs-comment">// 方法签名排序</span><br>        Arrays.sort(methSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">comp</span> <span class="hljs-operator">=</span> ms1.name.compareTo(ms2.name);<br>                <span class="hljs-keyword">if</span> (comp == <span class="hljs-number">0</span>) &#123;<br>                    comp = ms1.signature.compareTo(ms2.signature);<br>                &#125;<br>                <span class="hljs-keyword">return</span> comp;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; methSigs.length; i++) &#123;<br>            <span class="hljs-type">MemberSignature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> methSigs[i];<br>            <span class="hljs-comment">// 获取方法修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mods</span> <span class="hljs-operator">=</span> sig.member.getModifiers() &amp;<br>                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |<br>                 Modifier.STATIC | Modifier.FINAL |<br>                 Modifier.SYNCHRONIZED | Modifier.NATIVE |<br>                 Modifier.ABSTRACT | Modifier.STRICT);<br>            <span class="hljs-comment">// 非私有则写入</span><br>            <span class="hljs-keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="hljs-number">0</span>) &#123;<br>                dout.writeUTF(sig.name);<br>                dout.writeInt(mods);<br>                dout.writeUTF(sig.signature.replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 刷新，将结果保存到字节数组</span><br>        dout.flush();<br><br>        <span class="hljs-comment">// 对之前字节数组进行 SHA 运算</span><br>        <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA&quot;</span>);<br>        <span class="hljs-type">byte</span>[] hashBytes = md.digest(bout.toByteArray());<br>        <span class="hljs-type">long</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.min(hashBytes.length, <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            hash = (hash &lt;&lt; <span class="hljs-number">8</span>) | (hashBytes[i] &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(ex);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法看上去很长，其实做的事情是重复且容易理解，简单来说就是通过反射获取这个类的各种信息，将它们放到一个字节数组中，然后使用 <code>hash</code> 函数（SHA）进行运算得到一个代表类的“摘要”。这里作者已经充分注释了整个方法，读者可以通过粗略阅读来理解这个方法的具体细节。</p><blockquote><p>hash 函数是一种常用于加密或者生成信息摘要的方法，其特点主要有</p><ul><li>任意输入，固定输出</li><li>防碰撞，也叫做差之毫厘居距之千里，输入哪怕修改了 1 个位，计算出来结果也会发生大变化</li><li>单向性，其实也是任意输入，固定输出所决定的，通过 hash 值反向计算出原来的输入计算上是不可行的</li></ul><p>如果读者对这部分感兴趣，待作者开“区块链”专栏为读者一一介绍“加密的那些事情”</p></blockquote><h4 id="3-1-决定类-suid-的因素"><a href="#3-1-决定类-suid-的因素" class="headerlink" title="3.1 决定类 suid 的因素"></a>3.1 决定类 suid 的因素</h4><p>上面我们知道 hash 函数是产生这个 <code>suid</code> 的关键，那么要找决定 <code>suid</code> 的因素，首先寻找决定 hash 的因素，也就是 hash 的输入，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA&quot;</span>);<br><span class="hljs-comment">// 输入来源</span><br><span class="hljs-type">byte</span>[] hashBytes = md.digest(bout.toByteArray());<br><span class="hljs-type">long</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.min(hashBytes.length, <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    hash = (hash &lt;&lt; <span class="hljs-number">8</span>) | (hashBytes[i] &amp; <span class="hljs-number">0xFF</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到输入来自于 <code>bout</code> 变量，也就是我们要密切关注与下面俩个变量的操作，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 缓存 hash 输入的对象</span><br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-comment">// 方法中往 bout 写入的对象</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bout);<br></code></pre></td></tr></table></figure><p>我们只要找到与 <code>bout</code> 有关的动作就可以，上面作者已经将完整的代码注释了，读者可以阅读后看下面总结因素及引起 hash 值变化的具体动作，</p><table><thead><tr><th>因素</th><th>具体动作</th></tr></thead><tbody><tr><td>类名</td><td>修改类名</td></tr><tr><td>类修饰符</td><td>增加、减少和修改类修饰符</td></tr><tr><td>类接口</td><td>增加、减少和实现接口</td></tr><tr><td>类成员方法和构造方法</td><td>增加和减少方法；修改方法签名</td></tr><tr><td>类成员变量（包括静态、常量）</td><td>增加和减少变量；修改变量签名</td></tr></tbody></table><p>我们发现除了类所继承的类并不影响 <code>suid</code> 之外，其他类信息的变动都将修改类的 <code>suid</code>。</p><blockquote><p>其实这些因素里面还有一些不同的细节，作者已经在源码中标注了，比如对于私有构造方法，并不写入到 hash 输入中。</p><p>至于为什么当初的编写者不将类继承算进去，作者还在思考中</p></blockquote><h4 id="3-1-为什么要进行-Sort？"><a href="#3-1-为什么要进行-Sort？" class="headerlink" title="3.1 为什么要进行 Sort？"></a>3.1 为什么要进行 Sort？</h4><p>在阅读这个方法时，我们不难发现一些地方经常用到 <code>Array.sort()</code> 方法对各种反射得到的变量进行排序，比如下面的这段代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(fieldSigs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;<br>        <span class="hljs-keyword">return</span> ms1.name.compareTo(ms2.name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这段代码是对反射得到的类成员变量签名进行排序的方法，其实不难理解，目的就是成员变量之间的位置变换不应该影响一个类的 <code>suid</code>，比如我将 <code>User</code> 的两个成员变量位置互换，反序列化也不会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们的序列化源码分析就结束啦，这是作者花了非常大时间去创作的一篇源码分析，如果你喜欢我这样的新人的话，不妨点个赞。如果你觉得我有些地方可以改进，非常希望在评论区看到你哟！</p>]]></content>
    
    
    <categories>
      
      <category>爆肝源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
